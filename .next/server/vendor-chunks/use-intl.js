"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/_IntlProvider.js":
/*!*****************************************************!*\
  !*** ./node_modules/use-intl/dist/_IntlProvider.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDZJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1ibG9nLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvX0ludGxQcm92aWRlci5qcz9hODZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24vX0ludGxQcm92aWRlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L19JbnRsUHJvdmlkZXIuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/_useLocale.js":
/*!**************************************************!*\
  !*** ./node_modules/use-intl/dist/_useLocale.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_useLocale.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHVJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1ibG9nLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvX3VzZUxvY2FsZS5qcz8xNjFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24vX3VzZUxvY2FsZS5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L191c2VMb2NhbGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js":
/*!************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst IntlContext = /*#__PURE__*/ React.createContext(undefined);\nexports.IntlContext = IntlContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9JbnRsQ29udGV4dC1CS2ZzbnpCeC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1DLGNBQWMsV0FBVyxHQUFFRixNQUFNRyxhQUFhLENBQUNDO0FBRXJEQyxtQkFBbUIsR0FBR0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aWxpbmd1YWwtYmxvZy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L0ludGxDb250ZXh0LUJLZnNuekJ4LmpzPzU3NjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5jb25zdCBJbnRsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmV4cG9ydHMuSW50bENvbnRleHQgPSBJbnRsQ29udGV4dDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInJlcXVpcmUiLCJJbnRsQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_IntlProvider.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-BKfsnzBx.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\");\n__webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction IntlProvider(_ref) {\n    let { children, defaultTranslationValues, formats, getMessageFallback, locale, messages, now, onError, timeZone } = _ref;\n    // The formatter cache is released when the locale changes. For\n    // long-running apps with a persistent `IntlProvider` at the root,\n    // this can reduce the memory footprint (e.g. in React Native).\n    const cache = React.useMemo(()=>{\n        return initializeConfig.createCache();\n    }, [\n        locale\n    ]);\n    const formatters = React.useMemo(()=>initializeConfig.createIntlFormatters(cache), [\n        cache\n    ]);\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = React.useMemo(()=>({\n            ...initializeConfig.initializeConfig({\n                locale,\n                defaultTranslationValues,\n                formats,\n                getMessageFallback,\n                messages,\n                now,\n                onError,\n                timeZone\n            }),\n            formatters,\n            cache\n        }), [\n        cache,\n        defaultTranslationValues,\n        formats,\n        formatters,\n        getMessageFallback,\n        locale,\n        messages,\n        now,\n        onError,\n        timeZone\n    ]);\n    return /*#__PURE__*/ React__default.default.createElement(IntlContext.IntlContext.Provider, {\n        value: value\n    }, children);\n}\nexports.IntlProvider = IntlProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLG1CQUFtQkQsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUM7QUFDMUJBLG1CQUFPQSxDQUFDO0FBRVIsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyxpQkFBaUIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRWxELFNBQVNTLGFBQWFDLElBQUk7SUFDeEIsSUFBSSxFQUNGQyxRQUFRLEVBQ1JDLHdCQUF3QixFQUN4QkMsT0FBTyxFQUNQQyxrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxHQUFHLEVBQ0hDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdUO0lBQ0osK0RBQStEO0lBQy9ELGtFQUFrRTtJQUNsRSwrREFBK0Q7SUFDL0QsTUFBTVUsUUFBUXBCLE1BQU1xQixPQUFPLENBQUM7UUFDMUIsT0FBT25CLGlCQUFpQm9CLFdBQVc7SUFDckMsR0FBRztRQUFDUDtLQUFPO0lBQ1gsTUFBTVEsYUFBYXZCLE1BQU1xQixPQUFPLENBQUMsSUFBTW5CLGlCQUFpQnNCLG9CQUFvQixDQUFDSixRQUFRO1FBQUNBO0tBQU07SUFFNUYsb0VBQW9FO0lBQ3BFLHNFQUFzRTtJQUN0RSxxRUFBcUU7SUFDckUsMEVBQTBFO0lBQzFFLG1FQUFtRTtJQUNuRSx1RUFBdUU7SUFDdkUsMENBQTBDO0lBQzFDLCtKQUErSjtJQUMvSixNQUFNckIsUUFBUUMsTUFBTXFCLE9BQU8sQ0FBQyxJQUFPO1lBQ2pDLEdBQUduQixpQkFBaUJBLGdCQUFnQixDQUFDO2dCQUNuQ2E7Z0JBQ0FIO2dCQUNBQztnQkFDQUM7Z0JBQ0FFO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO1lBQ0YsRUFBRTtZQUNGSTtZQUNBSDtRQUNGLElBQUk7UUFBQ0E7UUFBT1I7UUFBMEJDO1FBQVNVO1FBQVlUO1FBQW9CQztRQUFRQztRQUFVQztRQUFLQztRQUFTQztLQUFTO0lBQ3hILE9BQU8sV0FBVyxHQUFFWCxlQUFlRCxPQUFPLENBQUNrQixhQUFhLENBQUN0QixZQUFZQSxXQUFXLENBQUN1QixRQUFRLEVBQUU7UUFDekYzQixPQUFPQTtJQUNULEdBQUdZO0FBQ0w7QUFFQWIsb0JBQW9CLEdBQUdXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzP2EzMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGluaXRpYWxpemVDb25maWcgPSByZXF1aXJlKCcuL2luaXRpYWxpemVDb25maWctQmhmTVNIUDcuanMnKTtcbnZhciBJbnRsQ29udGV4dCA9IHJlcXVpcmUoJy4vSW50bENvbnRleHQtQktmc256QnguanMnKTtcbnJlcXVpcmUoJ0Bmb3JtYXRqcy9mYXN0LW1lbW9pemUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcblxuZnVuY3Rpb24gSW50bFByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZm9ybWF0cyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSBfcmVmO1xuICAvLyBUaGUgZm9ybWF0dGVyIGNhY2hlIGlzIHJlbGVhc2VkIHdoZW4gdGhlIGxvY2FsZSBjaGFuZ2VzLiBGb3JcbiAgLy8gbG9uZy1ydW5uaW5nIGFwcHMgd2l0aCBhIHBlcnNpc3RlbnQgYEludGxQcm92aWRlcmAgYXQgdGhlIHJvb3QsXG4gIC8vIHRoaXMgY2FuIHJlZHVjZSB0aGUgbWVtb3J5IGZvb3RwcmludCAoZS5nLiBpbiBSZWFjdCBOYXRpdmUpLlxuICBjb25zdCBjYWNoZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBpbml0aWFsaXplQ29uZmlnLmNyZWF0ZUNhY2hlKCk7XG4gIH0sIFtsb2NhbGVdKTtcbiAgY29uc3QgZm9ybWF0dGVycyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksIFtjYWNoZV0pO1xuXG4gIC8vIE1lbW9pemluZyB0aGlzIHZhbHVlIGhlbHBzIHRvIGF2b2lkIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIgb2YgYWxsXG4gIC8vIGNvbnRleHQgY29uc3VtZXJzIGluIGNhc2UgdGhlIGNvbmZpZ3VyYXRpb24gZGlkbid0IGNoYW5nZS4gSG93ZXZlcixcbiAgLy8gaWYgc29tZSBvZiB0aGUgbm9uLXByaW1pdGl2ZSB2YWx1ZXMgY2hhbmdlLCBhIHJlLXJlbmRlciB3aWxsIHN0aWxsXG4gIC8vIGJlIHRyaWdnZXJlZC4gTm90ZSB0aGF0IHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXQgYG1lbW9gIG9uIGBJbnRsUHJvdmlkZXJgXG4gIC8vIGl0c2VsZiwgYmVjYXVzZSB0aGUgYGNoaWxkcmVuYCB0eXBpY2FsbHkgY2hhbmdlIG9uIGV2ZXJ5IHJlbmRlci5cbiAgLy8gVGhlcmUncyBzb21lIGJ1cmRlbiBvbiB0aGUgY29uc3VtZXIgc2lkZSBpZiBpdCdzIGltcG9ydGFudCB0byByZWR1Y2VcbiAgLy8gcmUtcmVuZGVycywgcHV0IHRoYXQncyBob3cgUmVhY3Qgd29ya3MuXG4gIC8vIFNlZTogaHR0cHM6Ly9ibG9nLmlzcXVhcmVkc29mdHdhcmUuY29tLzIwMjAvMDUvYmxvZ2dlZC1hbnN3ZXJzLWEtbW9zdGx5LWNvbXBsZXRlLWd1aWRlLXRvLXJlYWN0LXJlbmRlcmluZy1iZWhhdmlvci8jY29udGV4dC11cGRhdGVzLWFuZC1yZW5kZXItb3B0aW1pemF0aW9uc1xuICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5pbml0aWFsaXplQ29uZmlnLmluaXRpYWxpemVDb25maWcoe1xuICAgICAgbG9jYWxlLFxuICAgICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgICAgZm9ybWF0cyxcbiAgICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgbm93LFxuICAgICAgb25FcnJvcixcbiAgICAgIHRpbWVab25lXG4gICAgfSksXG4gICAgZm9ybWF0dGVycyxcbiAgICBjYWNoZVxuICB9KSwgW2NhY2hlLCBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsIGZvcm1hdHMsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgbG9jYWxlLCBtZXNzYWdlcywgbm93LCBvbkVycm9yLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbnRsQ29udGV4dC5JbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmV4cG9ydHMuSW50bFByb3ZpZGVyID0gSW50bFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVhY3QiLCJyZXF1aXJlIiwiaW5pdGlhbGl6ZUNvbmZpZyIsIkludGxDb250ZXh0IiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiUmVhY3RfX2RlZmF1bHQiLCJJbnRsUHJvdmlkZXIiLCJfcmVmIiwiY2hpbGRyZW4iLCJkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMiLCJmb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibG9jYWxlIiwibWVzc2FnZXMiLCJub3ciLCJvbkVycm9yIiwidGltZVpvbmUiLCJjYWNoZSIsInVzZU1lbW8iLCJjcmVhdGVDYWNoZSIsImZvcm1hdHRlcnMiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js":
/*!***********************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-BKfsnzBx.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\");\nfunction useIntlContext() {\n    const context = React.useContext(IntlContext.IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#client-server-components\");\n    }\n    return context;\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nexports.useIntlContext = useIntlContext;\nexports.useLocale = useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLUJLM2pPZWFBLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0U7SUFDUCxNQUFNQyxVQUFVSixNQUFNSyxVQUFVLENBQUNILFlBQVlBLFdBQVc7SUFDeEQsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNHO0lBQ1AsT0FBT0osaUJBQWlCSyxNQUFNO0FBQ2hDO0FBRUFDLHNCQUFzQixHQUFHTjtBQUN6Qk0saUJBQWlCLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLUJLM2pPZWFBLmpzPzg0ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEludGxDb250ZXh0ID0gcmVxdWlyZSgnLi9JbnRsQ29udGV4dC1CS2ZzbnpCeC5qcycpO1xuXG5mdW5jdGlvbiB1c2VJbnRsQ29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoSW50bENvbnRleHQuSW50bENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGludGwgY29udGV4dCBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGUgcHJvdmlkZXI/IFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9jb25maWd1cmF0aW9uI2NsaWVudC1zZXJ2ZXItY29tcG9uZW50cycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gdXNlTG9jYWxlKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS5sb2NhbGU7XG59XG5cbmV4cG9ydHMudXNlSW50bENvbnRleHQgPSB1c2VJbnRsQ29udGV4dDtcbmV4cG9ydHMudXNlTG9jYWxlID0gdXNlTG9jYWxlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIkludGxDb250ZXh0IiwidXNlSW50bENvbnRleHQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwidXNlTG9jYWxlIiwibG9jYWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale.js":
/*!**************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _useLocale = __webpack_require__(/*! ./_useLocale-BK3jOeaA.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-BKfsnzBx.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\");\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUlSSCxpQkFBaUIsR0FBR0UsV0FBV0UsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1ibG9nLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvX3VzZUxvY2FsZS5qcz81MGYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF91c2VMb2NhbGUgPSByZXF1aXJlKCcuL191c2VMb2NhbGUtQkszak9lYUEuanMnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5yZXF1aXJlKCcuL0ludGxDb250ZXh0LUJLZnNuekJ4LmpzJyk7XG5cblxuXG5leHBvcnRzLnVzZUxvY2FsZSA9IF91c2VMb2NhbGUudXNlTG9jYWxlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3VzZUxvY2FsZSIsInJlcXVpcmUiLCJ1c2VMb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-QqAaZwGD.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\");\n__webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { messages, namespace, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { _cache = initializeConfig.createCache(), _formatters = initializeConfig.createIntlFormatters(_cache), getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        cache: _cache,\n        formatters: _formatters,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports._createCache = initializeConfig.createCache;\nexports._createIntlFormatters = initializeConfig.createIntlFormatters;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLFFBQVEsRUFDUkMsU0FBUyxFQUNULEdBQUdDLE1BQ0osR0FBR0o7SUFDSixvREFBb0Q7SUFDcEQsOENBQThDO0lBQzlDRSxXQUFXQSxRQUFRLENBQUNELGdCQUFnQjtJQUNwQ0UsWUFBWUwsZ0JBQWdCTyxnQkFBZ0IsQ0FBQ0YsV0FBV0Y7SUFDeEQsT0FBT0gsZ0JBQWdCUSxvQkFBb0IsQ0FBQztRQUMxQyxHQUFHRixJQUFJO1FBQ1BGO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxpQkFBaUJQLElBQUk7SUFDNUIsSUFBSSxFQUNGUSxTQUFTWixpQkFBaUJhLFdBQVcsRUFBRSxFQUN2Q0MsY0FBY2QsaUJBQWlCZSxvQkFBb0IsQ0FBQ0gsT0FBTyxFQUMzREkscUJBQXFCaEIsaUJBQWlCaUIseUJBQXlCLEVBQy9EWCxRQUFRLEVBQ1JDLFNBQVMsRUFDVFcsVUFBVWxCLGlCQUFpQm1CLGNBQWMsRUFDekMsR0FBR1gsTUFDSixHQUFHSjtJQUNKLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsaUNBQWlDO0lBQ2pDLE9BQU9ELHFCQUFxQjtRQUMxQixHQUFHSyxJQUFJO1FBQ1BVO1FBQ0FFLE9BQU9SO1FBQ1BTLFlBQVlQO1FBQ1pFO1FBQ0EsK0ZBQStGO1FBQy9GVixVQUFVO1lBQ1IsS0FBS0E7UUFDUDtRQUNBQyxXQUFXQSxZQUFZLEtBQUtlLE1BQU0sQ0FBQ2YsYUFBYTtJQUNsRCxHQUFHO0FBQ0w7QUFFQVQsaUJBQWlCLEdBQUdFLGlCQUFpQnVCLFNBQVM7QUFDOUN6QixxQkFBcUIsR0FBR0UsaUJBQWlCd0IsYUFBYTtBQUN0RDFCLG9CQUFvQixHQUFHRSxpQkFBaUJhLFdBQVc7QUFDbkRmLDZCQUE2QixHQUFHRSxpQkFBaUJlLG9CQUFvQjtBQUNyRWpCLHdCQUF3QixHQUFHRSxpQkFBaUJBLGdCQUFnQjtBQUM1REYsdUJBQXVCLEdBQUdJLGdCQUFnQkEsZUFBZTtBQUN6REosd0JBQXdCLEdBQUdhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzP2RiODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1CaGZNU0hQNy5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLVFxQWFad0dELmpzJyk7XG5yZXF1aXJlKCdAZm9ybWF0anMvZmFzdC1tZW1vaXplJyk7XG5yZXF1aXJlKCdpbnRsLW1lc3NhZ2Vmb3JtYXQnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKF9yZWYsIG5hbWVzcGFjZVByZWZpeCkge1xuICBsZXQge1xuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgZnVuY3Rpb24gaW52b2NhdGlvbi5cbiAgbWVzc2FnZXMgPSBtZXNzYWdlc1tuYW1lc3BhY2VQcmVmaXhdO1xuICBuYW1lc3BhY2UgPSBjcmVhdGVGb3JtYXR0ZXIucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCk7XG4gIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIC4uLnJlc3QsXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlXG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcihfcmVmKSB7XG4gIGxldCB7XG4gICAgX2NhY2hlID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVDYWNoZSgpLFxuICAgIF9mb3JtYXR0ZXJzID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVJbnRsRm9ybWF0dGVycyhfY2FjaGUpLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvciA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdE9uRXJyb3IsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgZnVuY3Rpb24gc28gdGhlIHR5cGUgaW5mZXJlbmNlIGZvciB0aGUgb3B0aW9uYWxcbiAgLy8gbmFtZXNwYWNlIHdvcmtzIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAgLy8gVGhlIHByZWZpeCAoXCIhXCIpIGlzIGFyYml0cmFyeS5cbiAgcmV0dXJuIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5yZXN0LFxuICAgIG9uRXJyb3IsXG4gICAgY2FjaGU6IF9jYWNoZSxcbiAgICBmb3JtYXR0ZXJzOiBfZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgbWVzc2FnZXNgIGlzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAgaGVyZSBhbmQgd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHlcbiAgICBtZXNzYWdlczoge1xuICAgICAgJyEnOiBtZXNzYWdlc1xuICAgIH0sXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UgPyBcIiEuXCIuY29uY2F0KG5hbWVzcGFjZSkgOiAnISdcbiAgfSwgJyEnKTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuX2NyZWF0ZUNhY2hlID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVDYWNoZTtcbmV4cG9ydHMuX2NyZWF0ZUludGxGb3JtYXR0ZXJzID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVJbnRsRm9ybWF0dGVycztcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWcuaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyLmNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlVHJhbnNsYXRvciA9IGNyZWF0ZVRyYW5zbGF0b3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplQ29uZmlnIiwicmVxdWlyZSIsImNyZWF0ZUZvcm1hdHRlciIsImNyZWF0ZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsIm5hbWVzcGFjZVByZWZpeCIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwicmVzdCIsInJlc29sdmVOYW1lc3BhY2UiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNyZWF0ZVRyYW5zbGF0b3IiLCJfY2FjaGUiLCJjcmVhdGVDYWNoZSIsIl9mb3JtYXR0ZXJzIiwiY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwib25FcnJvciIsImRlZmF1bHRPbkVycm9yIiwiY2FjaGUiLCJmb3JtYXR0ZXJzIiwiY29uY2F0IiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsIl9jcmVhdGVDYWNoZSIsIl9jcmVhdGVJbnRsRm9ybWF0dGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone.dateTime\n        }\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = initializeConfig.memoFn(function() {\n        return new IntlMessageFormat__default.default(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], {\n            formatters: intlFormatters,\n            ...arguments.length <= 3 ? undefined : arguments[3]\n        });\n    }, cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { cache, defaultTranslationValues, formats: globalFormats, formatters, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone } = _ref;\n    const hasMessagesError = messagesOrError instanceof initializeConfig.IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (hasMessagesError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages\");\n                }\n            } else {\n                code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages\");\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat({\n                ...globalFormats,\n                ...formats\n            }, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch (_unused) {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { _cache: cache = initializeConfig.createCache(), _formatters: formatters = initializeConfig.createIntlFormatters(cache), formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function applyTimeZone(options) {\n        var _options;\n        if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone\"));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (_unused) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(/** If a number is supplied, this is interpreted as a UTC timestamp. */ start, /** If a number is supplied, this is interpreted as a UTC timestamp. */ end, /** If a time zone is supplied, the values are converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItUXFBYVp3R0QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELFNBQVNTLHFCQUFxQkMsT0FBTyxFQUFFQyxRQUFRO0lBQzdDLElBQUksQ0FBQ0QsU0FBUyxPQUFPQTtJQUVyQiw0RkFBNEY7SUFDNUYsc0hBQXNIO0lBQ3RILE9BQU9FLE9BQU9DLElBQUksQ0FBQ0gsU0FBU0ksTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQ3ZDRCxHQUFHLENBQUNDLElBQUksR0FBRztZQUNUTDtZQUNBLEdBQUdELE9BQU8sQ0FBQ00sSUFBSTtRQUNqQjtRQUNBLE9BQU9EO0lBQ1QsR0FBRyxDQUFDO0FBQ047QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxrQ0FBa0NQLE9BQU8sRUFBRUMsUUFBUTtJQUMxRCxNQUFNTyxzQkFBc0JQLFdBQVc7UUFDckMsR0FBR0QsT0FBTztRQUNWUyxVQUFVVixxQkFBcUJDLFFBQVFTLFFBQVEsRUFBRVI7SUFDbkQsSUFBSUQ7SUFDSixNQUFNVSxpQkFBaUJaLDJCQUEyQkQsT0FBTyxDQUFDRyxPQUFPLENBQUNXLElBQUk7SUFDdEUsTUFBTUMscUJBQXFCWCxXQUFXRixxQkFBcUJXLGdCQUFnQlQsWUFBWVM7SUFDdkYsTUFBTUcsaUJBQWlCZiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDYyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQmQsV0FBV0Ys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QU8rRyxJQUFJLENBQUM7WUFDckI7UUFDRixHQUFHLElBQU1sRSxPQUFPaEQ7SUFDbEI7SUFDQSxPQUFPO1FBQ0xqQztRQUNBb0o7UUFDQUk7UUFDQVU7UUFDQW5CO0lBQ0Y7QUFDRjtBQUVBaUMsNEJBQTRCLEdBQUcxSDtBQUMvQjBILHVCQUF1QixHQUFHcEQ7QUFDMUJvRCx3QkFBd0IsR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItUXFBYVp3R0QuanM/MjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChJbnRsTWVzc2FnZUZvcm1hdCk7XG5cbmZ1bmN0aW9uIHNldFRpbWVab25lSW5Gb3JtYXRzKGZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGlmICghZm9ybWF0cykgcmV0dXJuIGZvcm1hdHM7XG5cbiAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybWF0cykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0ge1xuICAgICAgdGltZVpvbmUsXG4gICAgICAuLi5mb3JtYXRzW2tleV1cbiAgICB9O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBgaW50bC1tZXNzYWdlZm9ybWF0YCB1c2VzIHNlcGFyYXRlIGtleXMgZm9yIGBkYXRlYCBhbmQgYHRpbWVgLCBidXQgdGhlcmUnc1xuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cbiAqIGluY2x1ZGUgYm90aCBhIHRpbWUgYW5kIGEgZGF0ZSBpbiBhIHZhbHVlLCB0aGVyZWZvcmUgdGhlIHNlcGFyYXRpb24gZG9lc24ndFxuICogc2VlbSBzbyB1c2VmdWwuIFdlIG9mZmVyIGEgc2luZ2xlIGBkYXRlVGltZWAgbmFtZXNwYWNlIGluc3RlYWQsIGJ1dCB3ZSBoYXZlXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZm9ybWF0cywgdGltZVpvbmUpIHtcbiAgY29uc3QgZm9ybWF0c1dpdGhUaW1lWm9uZSA9IHRpbWVab25lID8ge1xuICAgIC4uLmZvcm1hdHMsXG4gICAgZGF0ZVRpbWU6IHNldFRpbWVab25lSW5Gb3JtYXRzKGZvcm1hdHMuZGF0ZVRpbWUsIHRpbWVab25lKVxuICB9IDogZm9ybWF0cztcbiAgY29uc3QgbWZEYXRlRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0LmZvcm1hdHMuZGF0ZTtcbiAgY29uc3QgZGVmYXVsdERhdGVGb3JtYXRzID0gdGltZVpvbmUgPyBzZXRUaW1lWm9uZUluRm9ybWF0cyhtZkRhdGVEZWZhdWx0cywgdGltZVpvbmUpIDogbWZEYXRlRGVmYXVsdHM7XG4gIGNvbnN0IG1mVGltZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXRzLnRpbWU7XG4gIGNvbnN0IGRlZmF1bHRUaW1lRm9ybWF0cyA9IHRpbWVab25lID8gc2V0VGltZVpvbmVJbkZvcm1hdHMobWZUaW1lRGVmYXVsdHMsIHRpbWVab25lKSA6IG1mVGltZURlZmF1bHRzO1xuICByZXR1cm4ge1xuICAgIC4uLmZvcm1hdHNXaXRoVGltZVpvbmUsXG4gICAgZGF0ZToge1xuICAgICAgLi4uZGVmYXVsdERhdGVGb3JtYXRzLFxuICAgICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZVxuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4uZGVmYXVsdFRpbWVGb3JtYXRzLFxuICAgICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZVxuICAgIH1cbiAgfTtcbn1cblxuLy8gUGxhY2VkIGhlcmUgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZy4gU29tZWhvdyB3aGVuIHRoaXMgaXMgcGxhY2VkIGluXG4vLyBgZm9ybWF0dGVycy50c3hgLCB0aGVuIGl0IGNhbid0IGJlIHNoYWtlbiBvZmYgZnJvbSBgbmV4dC1pbnRsYC5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGludGxGb3JtYXR0ZXJzKSB7XG4gIGNvbnN0IGdldE1lc3NhZ2VGb3JtYXQgPSBpbml0aWFsaXplQ29uZmlnLm1lbW9GbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0sIHtcbiAgICAgIGZvcm1hdHRlcnM6IGludGxGb3JtYXR0ZXJzLFxuICAgICAgLi4uKGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1szXSlcbiAgICB9KTtcbiAgfSwgY2FjaGUubWVzc2FnZSk7XG4gIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAuXCIpICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGBcIi5jb25jYXQoZnVsbEtleSwgXCJgIGluIG1lc3NhZ2VzIGZvciBsb2NhbGUgYFwiKS5jb25jYXQobG9jYWxlLCBcImAuXCIpICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzE0NjdcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIGxldCB0cmFuc2Zvcm1lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGNodW5rcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKGNodW5rcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocmVzdWx0LCB7XG4gICAgICAgICAga2V5OiBrZXkgKyBpbmRleCsrXG4gICAgICAgIH0pIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtZWRWYWx1ZXNba2V5XSA9IHRyYW5zZm9ybWVkO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNPckVycm9yKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkge1xuICBsZXQgb25FcnJvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcjtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyB3ZXJlIGNvbmZpZ3VyZWQgb24gdGhlIHByb3ZpZGVyLlwiICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAgZm91bmQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCB1bmVzY2FwZWRNZXNzYWdlID0gY2FuZGlkYXRlLnJlcGxhY2UoLycoW3t9XSkvZ2ksICckMScpO1xuXG4gIC8vIFBsYWNlaG9sZGVycyBjYW4gYmUgaW4gdGhlIG1lc3NhZ2UgaWYgdGhlcmUgYXJlIGRlZmF1bHQgdmFsdWVzLFxuICAvLyBvciBpZiB0aGUgdXNlciBoYXMgZm9yZ290dGVuIHRvIHByb3ZpZGUgdmFsdWVzLiBJbiB0aGUgbGF0dGVyXG4gIC8vIGNhc2Ugd2UgbmVlZCB0byBjb21waWxlIHRoZSBtZXNzYWdlIHRvIHJlY2VpdmUgYW4gZXJyb3IuXG4gIGNvbnN0IGhhc1BsYWNlaG9sZGVycyA9IC88fHsvLnRlc3QodW5lc2NhcGVkTWVzc2FnZSk7XG4gIGlmICghaGFzUGxhY2Vob2xkZXJzKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoX3JlZikge1xuICBsZXQge1xuICAgIGNhY2hlLFxuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBtZXNzYWdlc09yRXJyb3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbigvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cykge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5TVUZGSUNJRU5UX1BBVEg7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBgLmAgdG8gcmV0cmlldmUgbmVzdGVkIG1lc3NhZ2VzLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvbWVzc2FnZXMjc3RydWN0dXJpbmctbWVzc2FnZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCh7XG4gICAgICAgIC4uLmdsb2JhbEZvcm1hdHMsXG4gICAgICAgIC4uLmZvcm1hdHNcbiAgICAgIH0sIHRpbWVab25lKSwge1xuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgLi4uZm9ybWF0dGVycyxcbiAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCB0aHJvd25FcnJvci5tZXNzYWdlICsgKCdvcmlnaW5hbE1lc3NhZ2UnIGluIHRocm93bkVycm9yID8gXCIgKFwiLmNvbmNhdCh0aHJvd25FcnJvci5vcmlnaW5hbE1lc3NhZ2UsIFwiKVwiKSA6ICcnKSApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMoe1xuICAgICAgICAuLi5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICAgIC4uLnZhbHVlc1xuICAgICAgfSkpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZm9ybWF0IGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJykgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgXCJUaGUgbWVzc2FnZSBgXCIuY29uY2F0KGtleSwgXCJgIGluIFwiKS5jb25jYXQobmFtZXNwYWNlID8gXCJuYW1lc3BhY2UgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYFwiKSA6ICdtZXNzYWdlcycsIFwiIGRpZG4ndCByZXNvbHZlIHRvIGEgc3RyaW5nLiBJZiB5b3Ugd2FudCB0byBmb3JtYXQgcmljaCB0ZXh0LCB1c2UgYHQucmljaGAgaW5zdGVhZC5cIikgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuXG4gIC8vIEF1Z21lbnQgYHRyYW5zbGF0ZUJhc2VGbmAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKGtleSwgdmFsdWVzLCBmb3JtYXRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGBNYXJrdXBUcmFuc2xhdGlvblZhbHVlc2AgaXMgcHJhY3RpY2FsbHkgYSBzdWIgdHlwZVxuICAgIC8vIG9mIGBSaWNoVHJhbnNsYXRpb25WYWx1ZXNgIGJ1dCBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCBoZXJlLlxuICAgIHZhbHVlcywgZm9ybWF0cyk7XG5cbiAgICAvLyBXaGVuIG9ubHkgc3RyaW5nIGNodW5rcyBhcmUgcHJvdmlkZWQgdG8gdGhlIHBhcnNlciwgb25seVxuICAgIC8vIHN0cmluZ3Mgc2hvdWxkIGJlIHJldHVybmVkIGhlcmUuIE5vdGUgdGhhdCB3ZSBuZWVkIGEgcnVudGltZVxuICAgIC8vIGNoZWNrIGZvciB0aGlzIHNpbmNlIHJpY2ggdGV4dCB2YWx1ZXMgY291bGQgYmUgYWNjaWRlbnRhbGx5XG4gICAgLy8gaW5oZXJpdGVkIGZyb20gYGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlc2AuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIiApO1xuICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgdHJhbnNsYXRlRm4ucmF3ID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhbnNsYXRlRm47XG59XG5cbi8qKlxuICogRm9yIHRoZSBzdHJpY3RseSB0eXBlZCBtZXNzYWdlcyB0byB3b3JrIHdlIGhhdmUgdG8gd3JhcCB0aGUgbmFtZXNwYWNlIGludG9cbiAqIGEgbWFuZGF0b3J5IHByZWZpeC4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICByZXR1cm4gbmFtZXNwYWNlID09PSBuYW1lc3BhY2VQcmVmaXggPyB1bmRlZmluZWQgOiBuYW1lc3BhY2Uuc2xpY2UoKG5hbWVzcGFjZVByZWZpeCArICcuJykubGVuZ3RoKTtcbn1cblxuY29uc3QgU0VDT05EID0gMTtcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xuY29uc3QgREFZID0gSE9VUiAqIDI0O1xuY29uc3QgV0VFSyA9IERBWSAqIDc7XG5jb25zdCBNT05USCA9IERBWSAqICgzNjUgLyAxMik7IC8vIEFwcHJveGltYXRpb25cbmNvbnN0IFFVQVJURVIgPSBNT05USCAqIDM7XG5jb25zdCBZRUFSID0gREFZICogMzY1O1xuY29uc3QgVU5JVF9TRUNPTkRTID0ge1xuICBzZWNvbmQ6IFNFQ09ORCxcbiAgc2Vjb25kczogU0VDT05ELFxuICBtaW51dGU6IE1JTlVURSxcbiAgbWludXRlczogTUlOVVRFLFxuICBob3VyOiBIT1VSLFxuICBob3VyczogSE9VUixcbiAgZGF5OiBEQVksXG4gIGRheXM6IERBWSxcbiAgd2VlazogV0VFSyxcbiAgd2Vla3M6IFdFRUssXG4gIG1vbnRoOiBNT05USCxcbiAgbW9udGhzOiBNT05USCxcbiAgcXVhcnRlcjogUVVBUlRFUixcbiAgcXVhcnRlcnM6IFFVQVJURVIsXG4gIHllYXI6IFlFQVIsXG4gIHllYXJzOiBZRUFSXG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykge1xuICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKHNlY29uZHMpO1xuICBpZiAoYWJzVmFsdWUgPCBNSU5VVEUpIHtcbiAgICByZXR1cm4gJ3NlY29uZCc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBIT1VSKSB7XG4gICAgcmV0dXJuICdtaW51dGUnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgREFZKSB7XG4gICAgcmV0dXJuICdob3VyJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFdFRUspIHtcbiAgICByZXR1cm4gJ2RheSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBNT05USCkge1xuICAgIHJldHVybiAnd2Vlayc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBZRUFSKSB7XG4gICAgcmV0dXJuICdtb250aCc7XG4gIH1cbiAgcmV0dXJuICd5ZWFyJztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpIHtcbiAgLy8gV2UgaGF2ZSB0byByb3VuZCB0aGUgcmVzdWx0aW5nIHZhbHVlcywgYXMgYEludGwuUmVsYXRpdmVUaW1lRm9ybWF0YFxuICAvLyB3aWxsIGluY2x1ZGUgZnJhY3Rpb25zIGxpa2UgJzIuMSBob3VycyBhZ28nLlxuICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzIC8gVU5JVF9TRUNPTkRTW3VuaXRdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgX2NhY2hlOiBjYWNoZSA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLFxuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zO1xuICAgIGlmICghKChfb3B0aW9ucyA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9vcHRpb25zICE9PSB2b2lkIDAgJiYgX29wdGlvbnMudGltZVpvbmUpKSB7XG4gICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBcIlRoZSBgdGltZVpvbmVgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVcIiApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzID09PSBudWxsIHx8IHR5cGVGb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlRm9ybWF0c1tmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIFwiRm9ybWF0IGBcIi5jb25jYXQoZm9ybWF0TmFtZSwgXCJgIGlzIG5vdCBhdmFpbGFibGUuIFlvdSBjYW4gY29uZmlndXJlIGl0IG9uIHRoZSBwcm92aWRlciBvciBwcm92aWRlIGN1c3RvbSBvcHRpb25zLlwiKSApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHZhbHVlLFxuICAvKiogSWYgYSB0aW1lIHpvbmUgaXMgc3VwcGxpZWQsIHRoZSBgdmFsdWVgIGlzIGNvbnZlcnRlZCB0byB0aGF0IHRpbWUgem9uZS5cbiAgICogT3RoZXJ3aXNlIHRoZSB1c2VyIHRpbWUgem9uZSB3aWxsIGJlIHVzZWQuICovXG4gIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZVJhbmdlKC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHN0YXJ0LCAvKiogSWYgYSBudW1iZXIgaXMgc3VwcGxpZWQsIHRoaXMgaXMgaW50ZXJwcmV0ZWQgYXMgYSBVVEMgdGltZXN0YW1wLiAqL1xuICBlbmQsXG4gIC8qKiBJZiBhIHRpbWUgem9uZSBpcyBzdXBwbGllZCwgdGhlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIHRoYXQgdGltZSB6b25lLlxuICAgKiBPdGhlcndpc2UgdGhlIHVzZXIgdGltZSB6b25lIHdpbGwgYmUgdXNlZC4gKi9cbiAgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMubnVtYmVyLCBvcHRpb25zID0+IGZvcm1hdHRlcnMuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsTm93KCkge1xuICAgIGlmIChnbG9iYWxOb3cpIHtcbiAgICAgIHJldHVybiBnbG9iYWxOb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGUgYG5vd2AgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI25vd1wiICkpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSgvKiogVGhlIGRhdGUgdGltZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZC4gKi9cbiAgZGF0ZSwgLyoqIFRoZSByZWZlcmVuY2UgcG9pbnQgaW4gdGltZSB0byB3aGljaCBgZGF0ZWAgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gcmVsYXRpb24gdG8uICAqL1xuICBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vd0RhdGUsIHVuaXQ7XG4gICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAobm93T3JPcHRpb25zKSB7XG4gICAgICAgIGlmIChub3dPck9wdGlvbnMubm93ICE9IG51bGwpIHtcbiAgICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zLm5vdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHVuaXQgPSBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgICAgb3B0cy5zdHlsZSA9IG5vd09yT3B0aW9ucy5zdHlsZTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlcyBhcmUgc2xpZ2h0bHkgb3V0ZGF0ZWRcbiAgICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0gPSBub3dPck9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgfVxuICAgICAgaWYgKCFub3dEYXRlKSB7XG4gICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBzZWNvbmRzID0gKGRhdGVEYXRlLmdldFRpbWUoKSAtIG5vd0RhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgdW5pdCA9IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCAtMS4xIGRheXMgd2lsbCBwcm9kdWNlIFwiLTEuMSBkYXlzXCIuIFJvdW5kaW5nIGJlZm9yZSBmb3JtYXR0aW5nIGlzXG4gICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAvLyAyMDI0LTAxLTA4VDAxOjAwOjAwLjAwMFogd291bGQgcHJvZHVjZSBcInllc3RlcmRheVwiLCB3aGljaCBpcyBub3QgdGhlXG4gICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgb3B0cy5udW1lcmljID0gdW5pdCA9PT0gJ3NlY29uZCcgPyAnYXV0bycgOiAnYWx3YXlzJztcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXRSZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRzKS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0dGVycy5nZXRMaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZUJhc2VUcmFuc2xhdG9yID0gY3JlYXRlQmFzZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMucmVzb2x2ZU5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2U7XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJyZXF1aXJlIiwiUmVhY3QiLCJpbml0aWFsaXplQ29uZmlnIiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQiLCJzZXRUaW1lWm9uZUluRm9ybWF0cyIsImZvcm1hdHMiLCJ0aW1lWm9uZSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJmb3JtYXRzV2l0aFRpbWVab25lIiwiZGF0ZVRpbWUiLCJtZkRhdGVEZWZhdWx0cyIsImRhdGUiLCJkZWZhdWx0RGF0ZUZvcm1hdHMiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkZWZhdWx0VGltZUZvcm1hdHMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiY2FjaGUiLCJpbnRsRm9ybWF0dGVycyIsImdldE1lc3NhZ2VGb3JtYXQiLCJtZW1vRm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJmb3JtYXR0ZXJzIiwibWVzc2FnZSIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJmdWxsS2V5Iiwiam9pblBhdGgiLCJFcnJvciIsImNvbmNhdCIsInNwbGl0IiwiZm9yRWFjaCIsInBhcnQiLCJuZXh0IiwicHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzIiwidmFsdWVzIiwidHJhbnNmb3JtZWRWYWx1ZXMiLCJpbmRleCIsInZhbHVlIiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsImdldE1lc3NhZ2VzT3JFcnJvciIsIm9uRXJyb3IiLCJkZWZhdWx0T25FcnJvciIsInJldHJpZXZlZE1lc3NhZ2VzIiwiZXJyb3IiLCJpbnRsRXJyb3IiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIiwiTUlTU0lOR19NRVNTQUdFIiwiZ2V0UGxhaW5NZXNzYWdlIiwiY2FuZGlkYXRlIiwidW5lc2NhcGVkTWVzc2FnZSIsInJlcGxhY2UiLCJoYXNQbGFjZWhvbGRlcnMiLCJ0ZXN0IiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjb25maWciLCJtZXNzYWdlc09yRXJyb3IiLCJjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwiLCJfcmVmIiwiZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzIiwiZ2xvYmFsRm9ybWF0cyIsImdldE1lc3NhZ2VGYWxsYmFjayIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJjb2RlIiwidHJhbnNsYXRlQmFzZUZuIiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJtZXNzYWdlRm9ybWF0IiwicGxhaW5NZXNzYWdlIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJsb2NhbGVzIiwib3B0aW9ucyIsInRocm93bkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiZm9ybWF0dGVkTWVzc2FnZSIsImZvcm1hdCIsIlN0cmluZyIsIkZPUk1BVFRJTkdfRVJST1IiLCJ0cmFuc2xhdGVGbiIsInJpY2giLCJtYXJrdXAiLCJyYXciLCJoYXMiLCJfdW51c2VkIiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwiX2NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJfZm9ybWF0dGVycyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwibm93IiwiZ2xvYmFsTm93IiwiZ2xvYmFsVGltZVpvbmUiLCJhcHBseVRpbWVab25lIiwiX29wdGlvbnMiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInJlc29sdmVGb3JtYXRPck9wdGlvbnMiLCJ0eXBlRm9ybWF0cyIsImZvcm1hdE9yT3B0aW9ucyIsImZvcm1hdE5hbWUiLCJNSVNTSU5HX0ZPUk1BVCIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVyIiwiZ2V0RmFsbGJhY2siLCJkYXRlVGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJmb3JtYXRSYW5nZSIsImpvaW4iLCJudW1iZXIiLCJnZXROdW1iZXJGb3JtYXQiLCJnZXRHbG9iYWxOb3ciLCJEYXRlIiwicmVsYXRpdmVUaW1lIiwibm93T3JPcHRpb25zIiwibm93RGF0ZSIsIm9wdHMiLCJzdHlsZSIsIm51bWJlcmluZ1N5c3RlbSIsImRhdGVEYXRlIiwiZ2V0VGltZSIsIm51bWVyaWMiLCJnZXRSZWxhdGl2ZVRpbWVGb3JtYXQiLCJsaXN0Iiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInNldCIsInB1c2giLCJnZXRMaXN0Rm9ybWF0IiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJnZXQiLCJzaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nvar core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/use-intl/dist/development/core.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-QqAaZwGD.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\");\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar react = __webpack_require__(/*! ./react.js */ \"(ssr)/./node_modules/use-intl/dist/development/react.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-BK3jOeaA.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js\");\n__webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-BKfsnzBx.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\");\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports._createCache = initializeConfig.createCache;\nexports._createIntlFormatters = initializeConfig.createIntlFormatters;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createTranslator = core.createTranslator;\nexports.createFormatter = createFormatter.createFormatter;\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useFormatter = react.useFormatter;\nexports.useMessages = react.useMessages;\nexports.useNow = react.useNow;\nexports.useTimeZone = react.useTimeZone;\nexports.useTranslations = react.useTranslations;\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDO0FBQy9CLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLGtCQUFrQkYsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxhQUFhTCxtQkFBT0EsQ0FBQztBQUN6QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFJUkgsaUJBQWlCLEdBQUdFLGlCQUFpQk8sU0FBUztBQUM5Q1QscUJBQXFCLEdBQUdFLGlCQUFpQlEsYUFBYTtBQUN0RFYsb0JBQW9CLEdBQUdFLGlCQUFpQlUsV0FBVztBQUNuRFosNkJBQTZCLEdBQUdFLGlCQUFpQlksb0JBQW9CO0FBQ3JFZCx3QkFBd0IsR0FBR0UsaUJBQWlCQSxnQkFBZ0I7QUFDNURGLHdCQUF3QixHQUFHSSxLQUFLVyxnQkFBZ0I7QUFDaERmLHVCQUF1QixHQUFHSyxnQkFBZ0JBLGVBQWU7QUFDekRMLG9CQUFvQixHQUFHTSxjQUFjVSxZQUFZO0FBQ2pEaEIsb0JBQW9CLEdBQUdPLE1BQU1VLFlBQVk7QUFDekNqQixtQkFBbUIsR0FBR08sTUFBTVcsV0FBVztBQUN2Q2xCLGNBQWMsR0FBR08sTUFBTVksTUFBTTtBQUM3Qm5CLG1CQUFtQixHQUFHTyxNQUFNYSxXQUFXO0FBQ3ZDcEIsdUJBQXVCLEdBQUdPLE1BQU1jLGVBQWU7QUFDL0NyQixpQkFBaUIsR0FBR1EsV0FBV2MsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1ibG9nLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanM/OTVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLVFxQWFad0dELmpzJyk7XG52YXIgX0ludGxQcm92aWRlciA9IHJlcXVpcmUoJy4vX0ludGxQcm92aWRlci5qcycpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgnLi9yZWFjdC5qcycpO1xudmFyIF91c2VMb2NhbGUgPSByZXF1aXJlKCcuL191c2VMb2NhbGUtQkszak9lYUEuanMnKTtcbnJlcXVpcmUoJ0Bmb3JtYXRqcy9mYXN0LW1lbW9pemUnKTtcbnJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xucmVxdWlyZSgncmVhY3QnKTtcbnJlcXVpcmUoJy4vSW50bENvbnRleHQtQktmc256QnguanMnKTtcblxuXG5cbmV4cG9ydHMuSW50bEVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3I7XG5leHBvcnRzLkludGxFcnJvckNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGU7XG5leHBvcnRzLl9jcmVhdGVDYWNoZSA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlQ2FjaGU7XG5leHBvcnRzLl9jcmVhdGVJbnRsRm9ybWF0dGVycyA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlSW50bEZvcm1hdHRlcnM7XG5leHBvcnRzLmluaXRpYWxpemVDb25maWcgPSBpbml0aWFsaXplQ29uZmlnLmluaXRpYWxpemVDb25maWc7XG5leHBvcnRzLmNyZWF0ZVRyYW5zbGF0b3IgPSBjb3JlLmNyZWF0ZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVGb3JtYXR0ZXI7XG5leHBvcnRzLkludGxQcm92aWRlciA9IF9JbnRsUHJvdmlkZXIuSW50bFByb3ZpZGVyO1xuZXhwb3J0cy51c2VGb3JtYXR0ZXIgPSByZWFjdC51c2VGb3JtYXR0ZXI7XG5leHBvcnRzLnVzZU1lc3NhZ2VzID0gcmVhY3QudXNlTWVzc2FnZXM7XG5leHBvcnRzLnVzZU5vdyA9IHJlYWN0LnVzZU5vdztcbmV4cG9ydHMudXNlVGltZVpvbmUgPSByZWFjdC51c2VUaW1lWm9uZTtcbmV4cG9ydHMudXNlVHJhbnNsYXRpb25zID0gcmVhY3QudXNlVHJhbnNsYXRpb25zO1xuZXhwb3J0cy51c2VMb2NhbGUgPSBfdXNlTG9jYWxlLnVzZUxvY2FsZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemVDb25maWciLCJyZXF1aXJlIiwiY29yZSIsImNyZWF0ZUZvcm1hdHRlciIsIl9JbnRsUHJvdmlkZXIiLCJyZWFjdCIsIl91c2VMb2NhbGUiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIiwiX2NyZWF0ZUNhY2hlIiwiY3JlYXRlQ2FjaGUiLCJfY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImNyZWF0ZVRyYW5zbGF0b3IiLCJJbnRsUHJvdmlkZXIiLCJ1c2VGb3JtYXR0ZXIiLCJ1c2VNZXNzYWdlcyIsInVzZU5vdyIsInVzZVRpbWVab25lIiwidXNlVHJhbnNsYXRpb25zIiwidXNlTG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar fastMemoize = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return fastMemoize.memoize(fn, {\n        cache: createMemoCache(cache),\n        strategy: fastMemoize.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return new ConstructorFn(...args);\n    }, cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.createCache = createCache;\nexports.createIntlFormatters = createIntlFormatters;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\nexports.memoFn = memoFn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsY0FBY0MsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0MsZ0JBQWdCQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUM5QixPQUFPLENBQUNELElBQUlFLGVBQWVGLEVBQUMsS0FBTUQsSUFBSUksT0FBT0MsY0FBYyxDQUFDTCxHQUFHQyxHQUFHO1FBQ2hFSyxPQUFPSjtRQUNQSyxZQUFZLENBQUM7UUFDYkMsY0FBYyxDQUFDO1FBQ2ZDLFVBQVUsQ0FBQztJQUNiLEtBQUtULENBQUMsQ0FBQ0MsRUFBRSxHQUFHQyxHQUFHRjtBQUNqQjtBQUNBLFNBQVNVLGFBQWFSLENBQUMsRUFBRUQsQ0FBQztJQUN4QixJQUFJLFlBQVksT0FBT0MsS0FBSyxDQUFDQSxHQUFHLE9BQU9BO0lBQ3ZDLElBQUlGLElBQUlFLENBQUMsQ0FBQ1MsT0FBT0MsV0FBVyxDQUFDO0lBQzdCLElBQUksS0FBSyxNQUFNWixHQUFHO1FBQ2hCLElBQUlhLElBQUliLEVBQUVjLElBQUksQ0FBQ1osR0FBR0QsS0FBSztRQUN2QixJQUFJLFlBQVksT0FBT1ksR0FBRyxPQUFPQTtRQUNqQyxNQUFNLElBQUlFLFVBQVU7SUFDdEI7SUFDQSxPQUFPLENBQUMsYUFBYWQsSUFBSWUsU0FBU0MsTUFBSyxFQUFHZjtBQUM1QztBQUNBLFNBQVNDLGVBQWVELENBQUM7SUFDdkIsSUFBSVcsSUFBSUgsYUFBYVIsR0FBRztJQUN4QixPQUFPLFlBQVksT0FBT1csSUFBSUEsSUFBSUEsSUFBSTtBQUN4QztBQUVBLElBQUlLLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJ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QUFNMEQsMEJBQTBCSCxzQkFBc0IzRDtJQUN0RDtRQUNFLElBQUk0QyxVQUFVO1lBQ1pXLGlCQUFpQlgsVUFBVWlCO1FBQzdCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsR0FBR0QsSUFBSTtRQUNQaEI7UUFDQVksU0FBU0s7UUFDVEYsb0JBQW9CRztJQUN0QjtBQUNGO0FBRUFDLGlCQUFpQixHQUFHL0U7QUFDcEIrRSxxQkFBcUIsR0FBR2hGO0FBQ3hCZ0YsbUJBQW1CLEdBQUd4RDtBQUN0QndELDRCQUE0QixHQUFHbEM7QUFDL0JrQyxpQ0FBaUMsR0FBRy9EO0FBQ3BDK0Qsc0JBQXNCLEdBQUczRDtBQUN6QjJELHdCQUF3QixHQUFHTDtBQUMzQkssZ0JBQWdCLEdBQUd6RTtBQUNuQnlFLGNBQWMsR0FBRzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzP2I3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmFzdE1lbW9pemUgPSByZXF1aXJlKCdAZm9ybWF0anMvZmFzdC1tZW1vaXplJyk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuXG5sZXQgSW50bEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSW50bEVycm9yQ29kZSkge1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19NRVNTQUdFXCJdID0gXCJNSVNTSU5HX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfRk9STUFUXCJdID0gXCJNSVNTSU5HX0ZPUk1BVFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIl0gPSBcIkVOVklST05NRU5UX0ZBTExCQUNLXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfUEFUSFwiXSA9IFwiSU5TVUZGSUNJRU5UX1BBVEhcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfTUVTU0FHRVwiXSA9IFwiSU5WQUxJRF9NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX0tFWVwiXSA9IFwiSU5WQUxJRF9LRVlcIjtcbiAgSW50bEVycm9yQ29kZVtcIkZPUk1BVFRJTkdfRVJST1JcIl0gPSBcIkZPUk1BVFRJTkdfRVJST1JcIjtcbiAgcmV0dXJuIEludGxFcnJvckNvZGU7XG59KHt9KTtcbmNsYXNzIEludGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJzogJyArIG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpvaW5QYXRoKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFydHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxuICogU2VlIGFsc28gYEluaXRpYWxpemVkSW50bENvbmZpZ3VyYXRpb25gLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2socHJvcHMpIHtcbiAgcmV0dXJuIGpvaW5QYXRoKHByb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZToge30sXG4gICAgbnVtYmVyOiB7fSxcbiAgICBtZXNzYWdlOiB7fSxcbiAgICByZWxhdGl2ZVRpbWU6IHt9LFxuICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICBsaXN0OiB7fSxcbiAgICBkaXNwbGF5TmFtZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vQ2FjaGUoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9GbihmbiwgY2FjaGUpIHtcbiAgcmV0dXJuIGZhc3RNZW1vaXplLm1lbW9pemUoZm4sIHtcbiAgICBjYWNoZTogY3JlYXRlTWVtb0NhY2hlKGNhY2hlKSxcbiAgICBzdHJhdGVneTogZmFzdE1lbW9pemUuc3RyYXRlZ2llcy52YXJpYWRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lbW9Db25zdHJ1Y3RvcihDb25zdHJ1Y3RvckZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb0ZuKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGbiguLi5hcmdzKTtcbiAgfSwgY2FjaGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EYXRlVGltZUZvcm1hdCwgY2FjaGUuZGF0ZVRpbWUpO1xuICBjb25zdCBnZXROdW1iZXJGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5OdW1iZXJGb3JtYXQsIGNhY2hlLm51bWJlcik7XG4gIGNvbnN0IGdldFBsdXJhbFJ1bGVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUGx1cmFsUnVsZXMsIGNhY2hlLnBsdXJhbFJ1bGVzKTtcbiAgY29uc3QgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LCBjYWNoZS5yZWxhdGl2ZVRpbWUpO1xuICBjb25zdCBnZXRMaXN0Rm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTGlzdEZvcm1hdCwgY2FjaGUubGlzdCk7XG4gIGNvbnN0IGdldERpc3BsYXlOYW1lcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRpc3BsYXlOYW1lcywgY2FjaGUuZGlzcGxheU5hbWVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICBnZXROdW1iZXJGb3JtYXQsXG4gICAgZ2V0UGx1cmFsUnVsZXMsXG4gICAgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0LFxuICAgIGdldExpc3RGb3JtYXQsXG4gICAgZ2V0RGlzcGxheU5hbWVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10gPSBfcmVmO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IFwiIChhdCBcIi5jb25jYXQocGFyZW50UGF0aCwgXCIpXCIpO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChtZXNzYWdlT3JNZXNzYWdlcyAhPSBudWxsICYmIHR5cGVvZiBtZXNzYWdlT3JNZXNzYWdlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VPck1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBqb2luUGF0aChwYXJlbnRQYXRoLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgb25FcnJvcikge1xuICBjb25zdCBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLklOVkFMSURfS0VZLCBcIk5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFxcXCIuXFxcIiBhcyB0aGlzIGlzIHVzZWQgdG8gZXhwcmVzcyBuZXN0aW5nLiBQbGVhc2UgcmVtb3ZlIGl0IG9yIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGNoYXJhY3Rlci5cXG5cXG5JbnZhbGlkIFwiLmNvbmNhdChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA9PT0gMSA/ICdrZXknIDogJ2tleXMnLCBcIjogXCIpLmNvbmNhdChpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJyksIFwiXFxuXFxuSWYgeW91J3JlIG1pZ3JhdGluZyBmcm9tIGEgZmxhdCBzdHJ1Y3R1cmUsIHlvdSBjYW4gY29udmVydCB5b3VyIG1lc3NhZ2VzIGFzIGZvbGxvd3M6XFxuXFxuaW1wb3J0IHtzZXR9IGZyb20gXFxcImxvZGFzaFxcXCI7XFxuXFxuY29uc3QgaW5wdXQgPSB7XFxuICBcXFwib25lLm9uZVxcXCI6IFxcXCIxLjFcXFwiLFxcbiAgXFxcIm9uZS50d29cXFwiOiBcXFwiMS4yXFxcIixcXG4gIFxcXCJ0d28ub25lLm9uZVxcXCI6IFxcXCIyLjEuMVxcXCJcXG59O1xcblxcbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXFxuICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHNldChhY2MsIGtleSwgdmFsdWUpLFxcbiAge31cXG4pO1xcblxcbi8vIE91dHB1dDpcXG4vL1xcbi8vIHtcXG4vLyAgIFxcXCJvbmVcXFwiOiB7XFxuLy8gICAgIFxcXCJvbmVcXFwiOiBcXFwiMS4xXFxcIixcXG4vLyAgICAgXFxcInR3b1xcXCI6IFxcXCIxLjJcXFwiXFxuLy8gICB9LFxcbi8vICAgXFxcInR3b1xcXCI6IHtcXG4vLyAgICAgXFxcIm9uZVxcXCI6IHtcXG4vLyAgICAgICBcXFwib25lXFxcIjogXFxcIjIuMS4xXFxcIlxcbi8vICAgICB9XFxuLy8gICB9XFxuLy8gfVxcblwiKSApKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VzIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgb25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBmaW5hbE9uRXJyb3IgPSBvbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xuICBjb25zdCBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgbWVzc2FnZXMsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBJbnRsRXJyb3I7XG5leHBvcnRzLkludGxFcnJvckNvZGUgPSBJbnRsRXJyb3JDb2RlO1xuZXhwb3J0cy5jcmVhdGVDYWNoZSA9IGNyZWF0ZUNhY2hlO1xuZXhwb3J0cy5jcmVhdGVJbnRsRm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzO1xuZXhwb3J0cy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbmV4cG9ydHMuZGVmYXVsdE9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcjtcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWc7XG5leHBvcnRzLmpvaW5QYXRoID0gam9pblBhdGg7XG5leHBvcnRzLm1lbW9GbiA9IG1lbW9GbjtcbiJdLCJuYW1lcyI6WyJmYXN0TWVtb2l6ZSIsInJlcXVpcmUiLCJfZGVmaW5lUHJvcGVydHkiLCJlIiwiciIsInQiLCJfdG9Qcm9wZXJ0eUtleSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiSW50bEVycm9yQ29kZSIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsImpvaW5QYXRoIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInBhcnRzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwicHJvcHMiLCJuYW1lc3BhY2UiLCJrZXkiLCJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZUNhY2hlIiwiZGF0ZVRpbWUiLCJudW1iZXIiLCJyZWxhdGl2ZVRpbWUiLCJwbHVyYWxSdWxlcyIsImxpc3QiLCJkaXNwbGF5TmFtZXMiLCJjcmVhdGVNZW1vQ2FjaGUiLCJzdG9yZSIsImNyZWF0ZSIsImdldCIsInNldCIsIm1lbW9GbiIsImZuIiwiY2FjaGUiLCJtZW1vaXplIiwic3RyYXRlZ3kiLCJzdHJhdGVnaWVzIiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJ2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudCIsIm1lc3NhZ2VzIiwiaW52YWxpZEtleUxhYmVscyIsInBhcmVudFBhdGgiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIl9yZWYiLCJtZXNzYWdlT3JNZXNzYWdlcyIsImluY2x1ZGVzIiwia2V5TGFiZWwiLCJjb25jYXQiLCJwdXNoIiwidmFsaWRhdGVNZXNzYWdlcyIsIm9uRXJyb3IiLCJJTlZBTElEX0tFWSIsImluaXRpYWxpemVDb25maWciLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJyZXN0IiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/react.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/react.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-BK3jOeaA.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-BK3jOeaA.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-QqAaZwGD.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\n__webpack_require__(/*! ./IntlContext-BKfsnzBx.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-BKfsnzBx.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n    const { cache, defaultTranslationValues, formats: globalFormats, formatters, getMessageFallback, locale, onError, timeZone } = _useLocale.useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    const allMessages = allMessagesPrefixed[namespacePrefix];\n    const namespace = createFormatter.resolveNamespace(namespacePrefixed, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        // eslint-disable-next-line react-compiler/react-compiler\n        hasWarnedForMissingTimezone = true;\n        onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"There is no `timeZone` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone\"));\n    }\n    const translate = React.useMemo(()=>createFormatter.createBaseTranslator({\n            cache,\n            formatters,\n            getMessageFallback,\n            messages: allMessages,\n            defaultTranslationValues,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        cache,\n        formatters,\n        getMessageFallback,\n        allMessages,\n        defaultTranslationValues,\n        namespace,\n        onError,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = _useLocale.useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? \"!.\".concat(namespace) : \"!\", \"!\");\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */ function useNow(options) {\n    const updateInterval = options === null || options === void 0 ? void 0 : options.updateInterval;\n    const { now: globalNow } = _useLocale.useIntlContext();\n    const [now, setNow] = React.useState(globalNow || getNow());\n    React.useEffect(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n    return _useLocale.useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = _useLocale.useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, formatters, locale, now: globalNow, onError, timeZone } = _useLocale.useIntlContext();\n    return React.useMemo(()=>createFormatter.createFormatter({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone,\n            _formatters: formatters\n        }), [\n        formats,\n        formatters,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useLocale = _useLocale.useLocale;\nexports.useFormatter = useFormatter;\nexports.useMessages = useMessages;\nexports.useNow = useNow;\nexports.useTimeZone = useTimeZone;\nexports.useTranslations = useTranslations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUksbUJBQW1CSixtQkFBT0EsQ0FBQztBQUMvQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJSyw4QkFBOEI7QUFDbEMsTUFBTUMsV0FBVyxnQkFBa0I7QUFDbkMsU0FBU0Msb0JBQW9CQyxtQkFBbUIsRUFBRUMsaUJBQWlCLEVBQUVDLGVBQWU7SUFDbEYsTUFBTSxFQUNKQyxLQUFLLEVBQ0xDLHdCQUF3QixFQUN4QkMsU0FBU0MsYUFBYSxFQUN0QkMsVUFBVSxFQUNWQyxrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR2xCLFdBQVdtQixjQUFjO0lBRTdCLG9EQUFvRDtJQUNwRCwwQ0FBMEM7SUFDMUMsTUFBTUMsY0FBY2IsbUJBQW1CLENBQUNFLGdCQUFnQjtJQUN4RCxNQUFNWSxZQUFZbkIsZ0JBQWdCb0IsZ0JBQWdCLENBQUNkLG1CQUFtQkM7SUFDdEUsSUFBSSxDQUFDUyxZQUFZLENBQUNkLCtCQUErQkMsVUFBVTtRQUN6RCx5REFBeUQ7UUFDekRELDhCQUE4QjtRQUM5QmEsUUFBUSxJQUFJZCxpQkFBaUJvQixTQUFTLENBQUNwQixpQkFBaUJxQixhQUFhLENBQUNDLG9CQUFvQixFQUFFO0lBQzlGO0lBQ0EsTUFBTUMsWUFBWXpCLE1BQU0wQixPQUFPLENBQUMsSUFBTXpCLGdCQUFnQjBCLG9CQUFvQixDQUFDO1lBQ3pFbEI7WUFDQUk7WUFDQUM7WUFDQWMsVUFBVVQ7WUFDVlQ7WUFDQVU7WUFDQUo7WUFDQUwsU0FBU0M7WUFDVEc7WUFDQUU7UUFDRixJQUFJO1FBQUNSO1FBQU9JO1FBQVlDO1FBQW9CSztRQUFhVDtRQUEwQlU7UUFBV0o7UUFBU0o7UUFBZUc7UUFBUUU7S0FBUztJQUN2SSxPQUFPUTtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNJLGdCQUFnQlQsU0FBUztJQUNoQyxNQUFNVSxVQUFVL0IsV0FBV21CLGNBQWM7SUFDekMsTUFBTVUsV0FBV0UsUUFBUUYsUUFBUTtJQUVqQyx5RUFBeUU7SUFDekUsNkVBQTZFO0lBQzdFLGlDQUFpQztJQUNqQyxPQUFPdkIsb0JBQW9CO1FBQ3pCLEtBQUt1QjtJQUNQLEdBQ0EsbUJBQW1CO0lBQ25CUixZQUFZLEtBQUtXLE1BQU0sQ0FBQ1gsYUFBYSxLQUFLO0FBQzVDO0FBRUEsU0FBU1k7SUFDUCxPQUFPLElBQUlDO0FBQ2I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTQyxPQUFPQyxPQUFPO0lBQ3JCLE1BQU1DLGlCQUFpQkQsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLGNBQWM7SUFDL0YsTUFBTSxFQUNKQyxLQUFLQyxTQUFTLEVBQ2YsR0FBR3ZDLFdBQVdtQixjQUFjO0lBQzdCLE1BQU0sQ0FBQ21CLEtBQUtFLE9BQU8sR0FBR3ZDLE1BQU13QyxRQUFRLENBQUNGLGFBQWFOO0lBQ2xEaEMsTUFBTXlDLFNBQVMsQ0FBQztRQUNkLElBQUksQ0FBQ0wsZ0JBQWdCO1FBQ3JCLE1BQU1NLGFBQWFDLFlBQVk7WUFDN0JKLE9BQU9QO1FBQ1QsR0FBR0k7UUFDSCxPQUFPO1lBQ0xRLGNBQWNGO1FBQ2hCO0lBQ0YsR0FBRztRQUFDSjtRQUFXRjtLQUFlO0lBQzlCLE9BQU9BLGtCQUFrQixRQUFRRSxZQUFZQSxZQUFZRDtBQUMzRDtBQUVBLFNBQVNRO0lBQ1AsT0FBTzlDLFdBQVdtQixjQUFjLEdBQUdELFFBQVE7QUFDN0M7QUFFQSxTQUFTNkI7SUFDUCxNQUFNaEIsVUFBVS9CLFdBQVdtQixjQUFjO0lBQ3pDLElBQUksQ0FBQ1ksUUFBUUYsUUFBUSxFQUFFO1FBQ3JCLE1BQU0sSUFBSW1CLE1BQU07SUFDbEI7SUFDQSxPQUFPakIsUUFBUUYsUUFBUTtBQUN6QjtBQUVBLFNBQVNvQjtJQUNQLE1BQU0sRUFDSnJDLE9BQU8sRUFDUEUsVUFBVSxFQUNWRSxNQUFNLEVBQ05zQixLQUFLQyxTQUFTLEVBQ2R0QixPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHbEIsV0FBV21CLGNBQWM7SUFDN0IsT0FBT2xCLE1BQU0wQixPQUFPLENBQUMsSUFBTXpCLGdCQUFnQkEsZUFBZSxDQUFDO1lBQ3pEVTtZQUNBSTtZQUNBc0IsS0FBS0M7WUFDTHRCO1lBQ0FDO1lBQ0FnQyxhQUFhcEM7UUFDZixJQUFJO1FBQUNGO1FBQVNFO1FBQVl5QjtRQUFXdkI7UUFBUUM7UUFBU0M7S0FBUztBQUNqRTtBQUVBdEIsb0JBQW9CLEdBQUdFLGNBQWNxRCxZQUFZO0FBQ2pEdkQsaUJBQWlCLEdBQUdJLFdBQVdvRCxTQUFTO0FBQ3hDeEQsb0JBQW9CLEdBQUdxRDtBQUN2QnJELG1CQUFtQixHQUFHbUQ7QUFDdEJuRCxjQUFjLEdBQUd1QztBQUNqQnZDLG1CQUFtQixHQUFHa0Q7QUFDdEJsRCx1QkFBdUIsR0FBR2tDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcz8yMTc1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9JbnRsUHJvdmlkZXIgPSByZXF1aXJlKCcuL19JbnRsUHJvdmlkZXIuanMnKTtcbnZhciBfdXNlTG9jYWxlID0gcmVxdWlyZSgnLi9fdXNlTG9jYWxlLUJLM2pPZWFBLmpzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLVFxQWFad0dELmpzJyk7XG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1CaGZNU0hQNy5qcycpO1xucmVxdWlyZSgnLi9JbnRsQ29udGV4dC1CS2ZzbnpCeC5qcycpO1xucmVxdWlyZSgnaW50bC1tZXNzYWdlZm9ybWF0Jyk7XG5yZXF1aXJlKCdAZm9ybWF0anMvZmFzdC1tZW1vaXplJyk7XG5cbmxldCBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSBmYWxzZTtcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VUcmFuc2xhdGlvbnNJbXBsKGFsbE1lc3NhZ2VzUHJlZml4ZWQsIG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgY29uc3Qge1xuICAgIGNhY2hlLFxuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSBfdXNlTG9jYWxlLnVzZUludGxDb250ZXh0KCk7XG5cbiAgLy8gVGhlIGBuYW1lc3BhY2VQcmVmaXhgIGlzIHBhcnQgb2YgdGhlIHR5cGUgc3lzdGVtLlxuICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIGhvb2sgaW52b2NhdGlvbi5cbiAgY29uc3QgYWxsTWVzc2FnZXMgPSBhbGxNZXNzYWdlc1ByZWZpeGVkW25hbWVzcGFjZVByZWZpeF07XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGNyZWF0ZUZvcm1hdHRlci5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtY29tcGlsZXIvcmVhY3QtY29tcGlsZXJcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGVyZSBpcyBubyBgdGltZVpvbmVgIGNvbmZpZ3VyZWQsIHRoaXMgY2FuIGxlYWQgdG8gbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdDogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVcIiApKTtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXM6IGFsbE1lc3NhZ2VzLFxuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICB0aW1lWm9uZVxuICB9KSwgW2NhY2hlLCBmb3JtYXR0ZXJzLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGFsbE1lc3NhZ2VzLCBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsIG5hbWVzcGFjZSwgb25FcnJvciwgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQubWVzc2FnZXM7XG5cbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgaG9vayBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IFwiIS5cIi5jb25jYXQobmFtZXNwYWNlKSA6ICchJywgJyEnKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cblxuLyoqXG4gKiBSZWFkaW5nIHRoZSBjdXJyZW50IGRhdGUgdmlhIGBuZXcgRGF0ZSgpYCBpbiBjb21wb25lbnRzIHNob3VsZCBiZSBhdm9pZGVkLCBhc1xuICogaXQgY2F1c2VzIGNvbXBvbmVudHMgdG8gYmUgaW1wdXJlIGFuZCBjYW4gbGVhZCB0byBmbGFreSB0ZXN0cy4gSW5zdGVhZCwgdGhpc1xuICogaG9vayBjYW4gYmUgdXNlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCByZXR1cm5zIHRoZSB0aW1lIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMuIElmIGB1cGRhdGVJbnRlcnZhbGBcbiAqIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIHdpbGwgYmUgdXBkYXRlZCBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwuXG4gKlxuICogWW91IGNhbiBob3dldmVyIGFsc28gcmV0dXJuIGEgc3RhdGljIHZhbHVlIGZyb20gdGhpcyBob29rLCBpZiB5b3VcbiAqIGNvbmZpZ3VyZSB0aGUgYG5vd2AgcGFyYW1ldGVyIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVyLiBOb3RlIGhvd2V2ZXIsXG4gKiB0aGF0IGlmIGB1cGRhdGVJbnRlcnZhbGAgaXMgY29uZmlndXJlZCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnRcbiAqIHdpbGwgaW5pdGlhbGl6ZSB3aXRoIHRoZSBnbG9iYWwgdmFsdWUsIGJ1dCB3aWxsIGFmdGVyd2FyZHMgdXBkYXRlXG4gKiBjb250aW51b3VzbHkgYmFzZWQgb24gdGhlIGludGVydmFsLlxuICpcbiAqIEZvciB1bml0IHRlc3RzLCB0aGlzIGNhbiBiZSBtb2NrZWQgdG8gYSBjb25zdGFudCB2YWx1ZS4gRm9yIGVuZC10by1lbmRcbiAqIHRlc3RpbmcsIGFuIGVudmlyb25tZW50IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgbm93YCBwYXJhbWV0ZXJcbiAqIG9mIHRoZSBwcm92aWRlciB0byBtb2NrIHRoaXMgdG8gYSBzdGF0aWMgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwZGF0ZUludGVydmFsO1xuICBjb25zdCB7XG4gICAgbm93OiBnbG9iYWxOb3dcbiAgfSA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IFJlYWN0LnVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gdXBkYXRlSW50ZXJ2YWwgPT0gbnVsbCAmJiBnbG9iYWxOb3cgPyBnbG9iYWxOb3cgOiBub3c7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVab25lKCkge1xuICByZXR1cm4gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpLnRpbWVab25lO1xufVxuXG5mdW5jdGlvbiB1c2VNZXNzYWdlcygpIHtcbiAgY29uc3QgY29udGV4dCA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0Lm1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXNzYWdlcyBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGVtIGNvcnJlY3RseT8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jbWVzc2FnZXMnICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQubWVzc2FnZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1hdHRlcigpIHtcbiAgY29uc3Qge1xuICAgIGZvcm1hdHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBsb2NhbGUsXG4gICAgbm93OiBnbG9iYWxOb3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzXG4gIH0pLCBbZm9ybWF0cywgZm9ybWF0dGVycywgZ2xvYmFsTm93LCBsb2NhbGUsIG9uRXJyb3IsIHRpbWVab25lXSk7XG59XG5cbmV4cG9ydHMuSW50bFByb3ZpZGVyID0gX0ludGxQcm92aWRlci5JbnRsUHJvdmlkZXI7XG5leHBvcnRzLnVzZUxvY2FsZSA9IF91c2VMb2NhbGUudXNlTG9jYWxlO1xuZXhwb3J0cy51c2VGb3JtYXR0ZXIgPSB1c2VGb3JtYXR0ZXI7XG5leHBvcnRzLnVzZU1lc3NhZ2VzID0gdXNlTWVzc2FnZXM7XG5leHBvcnRzLnVzZU5vdyA9IHVzZU5vdztcbmV4cG9ydHMudXNlVGltZVpvbmUgPSB1c2VUaW1lWm9uZTtcbmV4cG9ydHMudXNlVHJhbnNsYXRpb25zID0gdXNlVHJhbnNsYXRpb25zO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX0ludGxQcm92aWRlciIsInJlcXVpcmUiLCJfdXNlTG9jYWxlIiwiUmVhY3QiLCJjcmVhdGVGb3JtYXR0ZXIiLCJpbml0aWFsaXplQ29uZmlnIiwiaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lIiwiaXNTZXJ2ZXIiLCJ1c2VUcmFuc2xhdGlvbnNJbXBsIiwiYWxsTWVzc2FnZXNQcmVmaXhlZCIsIm5hbWVzcGFjZVByZWZpeGVkIiwibmFtZXNwYWNlUHJlZml4IiwiY2FjaGUiLCJkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMiLCJmb3JtYXRzIiwiZ2xvYmFsRm9ybWF0cyIsImZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJsb2NhbGUiLCJvbkVycm9yIiwidGltZVpvbmUiLCJ1c2VJbnRsQ29udGV4dCIsImFsbE1lc3NhZ2VzIiwibmFtZXNwYWNlIiwicmVzb2x2ZU5hbWVzcGFjZSIsIkludGxFcnJvciIsIkludGxFcnJvckNvZGUiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInRyYW5zbGF0ZSIsInVzZU1lbW8iLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsIm1lc3NhZ2VzIiwidXNlVHJhbnNsYXRpb25zIiwiY29udGV4dCIsImNvbmNhdCIsImdldE5vdyIsIkRhdGUiLCJ1c2VOb3ciLCJvcHRpb25zIiwidXBkYXRlSW50ZXJ2YWwiLCJub3ciLCJnbG9iYWxOb3ciLCJzZXROb3ciLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImludGVydmFsSWQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VUaW1lWm9uZSIsInVzZU1lc3NhZ2VzIiwiRXJyb3IiLCJ1c2VGb3JtYXR0ZXIiLCJfZm9ybWF0dGVycyIsIkludGxQcm92aWRlciIsInVzZUxvY2FsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/react.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/use-intl/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/index.js */ \"(ssr)/./node_modules/use-intl/dist/development/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyw2SEFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aWxpbmd1YWwtYmxvZy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2luZGV4LmpzPzdiMTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHJvZHVjdGlvbi9pbmRleC5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-QqAaZwGD.js */ \"(rsc)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\");\n__webpack_require__(/*! @formatjs/fast-memoize */ \"(rsc)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n__webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { messages, namespace, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { _cache = initializeConfig.createCache(), _formatters = initializeConfig.createIntlFormatters(_cache), getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        cache: _cache,\n        formatters: _formatters,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports._createCache = initializeConfig.createCache;\nexports._createIntlFormatters = initializeConfig.createIntlFormatters;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLFFBQVEsRUFDUkMsU0FBUyxFQUNULEdBQUdDLE1BQ0osR0FBR0o7SUFDSixvREFBb0Q7SUFDcEQsOENBQThDO0lBQzlDRSxXQUFXQSxRQUFRLENBQUNELGdCQUFnQjtJQUNwQ0UsWUFBWUwsZ0JBQWdCTyxnQkFBZ0IsQ0FBQ0YsV0FBV0Y7SUFDeEQsT0FBT0gsZ0JBQWdCUSxvQkFBb0IsQ0FBQztRQUMxQyxHQUFHRixJQUFJO1FBQ1BGO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxpQkFBaUJQLElBQUk7SUFDNUIsSUFBSSxFQUNGUSxTQUFTWixpQkFBaUJhLFdBQVcsRUFBRSxFQUN2Q0MsY0FBY2QsaUJBQWlCZSxvQkFBb0IsQ0FBQ0gsT0FBTyxFQUMzREkscUJBQXFCaEIsaUJBQWlCaUIseUJBQXlCLEVBQy9EWCxRQUFRLEVBQ1JDLFNBQVMsRUFDVFcsVUFBVWxCLGlCQUFpQm1CLGNBQWMsRUFDekMsR0FBR1gsTUFDSixHQUFHSjtJQUNKLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsaUNBQWlDO0lBQ2pDLE9BQU9ELHFCQUFxQjtRQUMxQixHQUFHSyxJQUFJO1FBQ1BVO1FBQ0FFLE9BQU9SO1FBQ1BTLFlBQVlQO1FBQ1pFO1FBQ0EsK0ZBQStGO1FBQy9GVixVQUFVO1lBQ1IsS0FBS0E7UUFDUDtRQUNBQyxXQUFXQSxZQUFZLEtBQUtlLE1BQU0sQ0FBQ2YsYUFBYTtJQUNsRCxHQUFHO0FBQ0w7QUFFQVQsaUJBQWlCLEdBQUdFLGlCQUFpQnVCLFNBQVM7QUFDOUN6QixxQkFBcUIsR0FBR0UsaUJBQWlCd0IsYUFBYTtBQUN0RDFCLG9CQUFvQixHQUFHRSxpQkFBaUJhLFdBQVc7QUFDbkRmLDZCQUE2QixHQUFHRSxpQkFBaUJlLG9CQUFvQjtBQUNyRWpCLHdCQUF3QixHQUFHRSxpQkFBaUJBLGdCQUFnQjtBQUM1REYsdUJBQXVCLEdBQUdJLGdCQUFnQkEsZUFBZTtBQUN6REosd0JBQXdCLEdBQUdhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzP2RiODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1CaGZNU0hQNy5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLVFxQWFad0dELmpzJyk7XG5yZXF1aXJlKCdAZm9ybWF0anMvZmFzdC1tZW1vaXplJyk7XG5yZXF1aXJlKCdpbnRsLW1lc3NhZ2Vmb3JtYXQnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKF9yZWYsIG5hbWVzcGFjZVByZWZpeCkge1xuICBsZXQge1xuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgZnVuY3Rpb24gaW52b2NhdGlvbi5cbiAgbWVzc2FnZXMgPSBtZXNzYWdlc1tuYW1lc3BhY2VQcmVmaXhdO1xuICBuYW1lc3BhY2UgPSBjcmVhdGVGb3JtYXR0ZXIucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCk7XG4gIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIC4uLnJlc3QsXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlXG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcihfcmVmKSB7XG4gIGxldCB7XG4gICAgX2NhY2hlID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVDYWNoZSgpLFxuICAgIF9mb3JtYXR0ZXJzID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVJbnRsRm9ybWF0dGVycyhfY2FjaGUpLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvciA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdE9uRXJyb3IsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgZnVuY3Rpb24gc28gdGhlIHR5cGUgaW5mZXJlbmNlIGZvciB0aGUgb3B0aW9uYWxcbiAgLy8gbmFtZXNwYWNlIHdvcmtzIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAgLy8gVGhlIHByZWZpeCAoXCIhXCIpIGlzIGFyYml0cmFyeS5cbiAgcmV0dXJuIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5yZXN0LFxuICAgIG9uRXJyb3IsXG4gICAgY2FjaGU6IF9jYWNoZSxcbiAgICBmb3JtYXR0ZXJzOiBfZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgbWVzc2FnZXNgIGlzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAgaGVyZSBhbmQgd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHlcbiAgICBtZXNzYWdlczoge1xuICAgICAgJyEnOiBtZXNzYWdlc1xuICAgIH0sXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UgPyBcIiEuXCIuY29uY2F0KG5hbWVzcGFjZSkgOiAnISdcbiAgfSwgJyEnKTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuX2NyZWF0ZUNhY2hlID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVDYWNoZTtcbmV4cG9ydHMuX2NyZWF0ZUludGxGb3JtYXR0ZXJzID0gaW5pdGlhbGl6ZUNvbmZpZy5jcmVhdGVJbnRsRm9ybWF0dGVycztcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWcuaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyLmNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlVHJhbnNsYXRvciA9IGNyZWF0ZVRyYW5zbGF0b3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplQ29uZmlnIiwicmVxdWlyZSIsImNyZWF0ZUZvcm1hdHRlciIsImNyZWF0ZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsIm5hbWVzcGFjZVByZWZpeCIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwicmVzdCIsInJlc29sdmVOYW1lc3BhY2UiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNyZWF0ZVRyYW5zbGF0b3IiLCJfY2FjaGUiLCJjcmVhdGVDYWNoZSIsIl9mb3JtYXR0ZXJzIiwiY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwib25FcnJvciIsImRlZmF1bHRPbkVycm9yIiwiY2FjaGUiLCJmb3JtYXR0ZXJzIiwiY29uY2F0IiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsIl9jcmVhdGVDYWNoZSIsIl9jcmVhdGVJbnRsRm9ybWF0dGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-BhfMSHP7.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone.dateTime\n        }\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = initializeConfig.memoFn(function() {\n        return new IntlMessageFormat__default.default(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], {\n            formatters: intlFormatters,\n            ...arguments.length <= 3 ? undefined : arguments[3]\n        });\n    }, cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { cache, defaultTranslationValues, formats: globalFormats, formatters, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone } = _ref;\n    const hasMessagesError = messagesOrError instanceof initializeConfig.IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (hasMessagesError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages\");\n                }\n            } else {\n                code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages\");\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat({\n                ...globalFormats,\n                ...formats\n            }, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch (_unused) {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { _cache: cache = initializeConfig.createCache(), _formatters: formatters = initializeConfig.createIntlFormatters(cache), formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function applyTimeZone(options) {\n        var _options;\n        if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone\"));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (_unused) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(/** If a number is supplied, this is interpreted as a UTC timestamp. */ start, /** If a number is supplied, this is interpreted as a UTC timestamp. */ end, /** If a time zone is supplied, the values are converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItUXFBYVp3R0QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELFNBQVNTLHFCQUFxQkMsT0FBTyxFQUFFQyxRQUFRO0lBQzdDLElBQUksQ0FBQ0QsU0FBUyxPQUFPQTtJQUVyQiw0RkFBNEY7SUFDNUYsc0hBQXNIO0lBQ3RILE9BQU9FLE9BQU9DLElBQUksQ0FBQ0gsU0FBU0ksTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQ3ZDRCxHQUFHLENBQUNDLElBQUksR0FBRztZQUNUTDtZQUNBLEdBQUdELE9BQU8sQ0FBQ00sSUFBSTtRQUNqQjtRQUNBLE9BQU9EO0lBQ1QsR0FBRyxDQUFDO0FBQ047QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxrQ0FBa0NQLE9BQU8sRUFBRUMsUUFBUTtJQUMxRCxNQUFNTyxzQkFBc0JQLFdBQVc7UUFDckMsR0FBR0QsT0FBTztRQUNWUyxVQUFVVixxQkFBcUJDLFFBQVFTLFFBQVEsRUFBRVI7SUFDbkQsSUFBSUQ7SUFDSixNQUFNVSxpQkFBaUJaLDJCQUEyQkQsT0FBTyxDQUFDRyxPQUFPLENBQUNXLElBQUk7SUFDdEUsTUFBTUMscUJBQXFCWCxXQUFXRixxQkFBcUJXLGdCQUFnQlQsWUFBWVM7SUFDdkYsTUFBTUcsaUJBQWlCZiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDYyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQmQsV0FBV0Ys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QU8rRyxJQUFJLENBQUM7WUFDckI7UUFDRixHQUFHLElBQU1sRSxPQUFPaEQ7SUFDbEI7SUFDQSxPQUFPO1FBQ0xqQztRQUNBb0o7UUFDQUk7UUFDQVU7UUFDQW5CO0lBQ0Y7QUFDRjtBQUVBaUMsNEJBQTRCLEdBQUcxSDtBQUMvQjBILHVCQUF1QixHQUFHcEQ7QUFDMUJvRCx3QkFBd0IsR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItUXFBYVp3R0QuanM/MjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChJbnRsTWVzc2FnZUZvcm1hdCk7XG5cbmZ1bmN0aW9uIHNldFRpbWVab25lSW5Gb3JtYXRzKGZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGlmICghZm9ybWF0cykgcmV0dXJuIGZvcm1hdHM7XG5cbiAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybWF0cykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0ge1xuICAgICAgdGltZVpvbmUsXG4gICAgICAuLi5mb3JtYXRzW2tleV1cbiAgICB9O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBgaW50bC1tZXNzYWdlZm9ybWF0YCB1c2VzIHNlcGFyYXRlIGtleXMgZm9yIGBkYXRlYCBhbmQgYHRpbWVgLCBidXQgdGhlcmUnc1xuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cbiAqIGluY2x1ZGUgYm90aCBhIHRpbWUgYW5kIGEgZGF0ZSBpbiBhIHZhbHVlLCB0aGVyZWZvcmUgdGhlIHNlcGFyYXRpb24gZG9lc24ndFxuICogc2VlbSBzbyB1c2VmdWwuIFdlIG9mZmVyIGEgc2luZ2xlIGBkYXRlVGltZWAgbmFtZXNwYWNlIGluc3RlYWQsIGJ1dCB3ZSBoYXZlXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZm9ybWF0cywgdGltZVpvbmUpIHtcbiAgY29uc3QgZm9ybWF0c1dpdGhUaW1lWm9uZSA9IHRpbWVab25lID8ge1xuICAgIC4uLmZvcm1hdHMsXG4gICAgZGF0ZVRpbWU6IHNldFRpbWVab25lSW5Gb3JtYXRzKGZvcm1hdHMuZGF0ZVRpbWUsIHRpbWVab25lKVxuICB9IDogZm9ybWF0cztcbiAgY29uc3QgbWZEYXRlRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0LmZvcm1hdHMuZGF0ZTtcbiAgY29uc3QgZGVmYXVsdERhdGVGb3JtYXRzID0gdGltZVpvbmUgPyBzZXRUaW1lWm9uZUluRm9ybWF0cyhtZkRhdGVEZWZhdWx0cywgdGltZVpvbmUpIDogbWZEYXRlRGVmYXVsdHM7XG4gIGNvbnN0IG1mVGltZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXRzLnRpbWU7XG4gIGNvbnN0IGRlZmF1bHRUaW1lRm9ybWF0cyA9IHRpbWVab25lID8gc2V0VGltZVpvbmVJbkZvcm1hdHMobWZUaW1lRGVmYXVsdHMsIHRpbWVab25lKSA6IG1mVGltZURlZmF1bHRzO1xuICByZXR1cm4ge1xuICAgIC4uLmZvcm1hdHNXaXRoVGltZVpvbmUsXG4gICAgZGF0ZToge1xuICAgICAgLi4uZGVmYXVsdERhdGVGb3JtYXRzLFxuICAgICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZVxuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4uZGVmYXVsdFRpbWVGb3JtYXRzLFxuICAgICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZVxuICAgIH1cbiAgfTtcbn1cblxuLy8gUGxhY2VkIGhlcmUgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZy4gU29tZWhvdyB3aGVuIHRoaXMgaXMgcGxhY2VkIGluXG4vLyBgZm9ybWF0dGVycy50c3hgLCB0aGVuIGl0IGNhbid0IGJlIHNoYWtlbiBvZmYgZnJvbSBgbmV4dC1pbnRsYC5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGludGxGb3JtYXR0ZXJzKSB7XG4gIGNvbnN0IGdldE1lc3NhZ2VGb3JtYXQgPSBpbml0aWFsaXplQ29uZmlnLm1lbW9GbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0sIHtcbiAgICAgIGZvcm1hdHRlcnM6IGludGxGb3JtYXR0ZXJzLFxuICAgICAgLi4uKGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1szXSlcbiAgICB9KTtcbiAgfSwgY2FjaGUubWVzc2FnZSk7XG4gIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAuXCIpICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGBcIi5jb25jYXQoZnVsbEtleSwgXCJgIGluIG1lc3NhZ2VzIGZvciBsb2NhbGUgYFwiKS5jb25jYXQobG9jYWxlLCBcImAuXCIpICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzE0NjdcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIGxldCB0cmFuc2Zvcm1lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGNodW5rcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKGNodW5rcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocmVzdWx0LCB7XG4gICAgICAgICAga2V5OiBrZXkgKyBpbmRleCsrXG4gICAgICAgIH0pIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtZWRWYWx1ZXNba2V5XSA9IHRyYW5zZm9ybWVkO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNPckVycm9yKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkge1xuICBsZXQgb25FcnJvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcjtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyB3ZXJlIGNvbmZpZ3VyZWQgb24gdGhlIHByb3ZpZGVyLlwiICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAgZm91bmQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCB1bmVzY2FwZWRNZXNzYWdlID0gY2FuZGlkYXRlLnJlcGxhY2UoLycoW3t9XSkvZ2ksICckMScpO1xuXG4gIC8vIFBsYWNlaG9sZGVycyBjYW4gYmUgaW4gdGhlIG1lc3NhZ2UgaWYgdGhlcmUgYXJlIGRlZmF1bHQgdmFsdWVzLFxuICAvLyBvciBpZiB0aGUgdXNlciBoYXMgZm9yZ290dGVuIHRvIHByb3ZpZGUgdmFsdWVzLiBJbiB0aGUgbGF0dGVyXG4gIC8vIGNhc2Ugd2UgbmVlZCB0byBjb21waWxlIHRoZSBtZXNzYWdlIHRvIHJlY2VpdmUgYW4gZXJyb3IuXG4gIGNvbnN0IGhhc1BsYWNlaG9sZGVycyA9IC88fHsvLnRlc3QodW5lc2NhcGVkTWVzc2FnZSk7XG4gIGlmICghaGFzUGxhY2Vob2xkZXJzKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoX3JlZikge1xuICBsZXQge1xuICAgIGNhY2hlLFxuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBtZXNzYWdlc09yRXJyb3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbigvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cykge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5TVUZGSUNJRU5UX1BBVEg7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBgLmAgdG8gcmV0cmlldmUgbmVzdGVkIG1lc3NhZ2VzLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvbWVzc2FnZXMjc3RydWN0dXJpbmctbWVzc2FnZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCh7XG4gICAgICAgIC4uLmdsb2JhbEZvcm1hdHMsXG4gICAgICAgIC4uLmZvcm1hdHNcbiAgICAgIH0sIHRpbWVab25lKSwge1xuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgLi4uZm9ybWF0dGVycyxcbiAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCB0aHJvd25FcnJvci5tZXNzYWdlICsgKCdvcmlnaW5hbE1lc3NhZ2UnIGluIHRocm93bkVycm9yID8gXCIgKFwiLmNvbmNhdCh0aHJvd25FcnJvci5vcmlnaW5hbE1lc3NhZ2UsIFwiKVwiKSA6ICcnKSApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMoe1xuICAgICAgICAuLi5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICAgIC4uLnZhbHVlc1xuICAgICAgfSkpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZm9ybWF0IGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJykgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgXCJUaGUgbWVzc2FnZSBgXCIuY29uY2F0KGtleSwgXCJgIGluIFwiKS5jb25jYXQobmFtZXNwYWNlID8gXCJuYW1lc3BhY2UgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYFwiKSA6ICdtZXNzYWdlcycsIFwiIGRpZG4ndCByZXNvbHZlIHRvIGEgc3RyaW5nLiBJZiB5b3Ugd2FudCB0byBmb3JtYXQgcmljaCB0ZXh0LCB1c2UgYHQucmljaGAgaW5zdGVhZC5cIikgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuXG4gIC8vIEF1Z21lbnQgYHRyYW5zbGF0ZUJhc2VGbmAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKGtleSwgdmFsdWVzLCBmb3JtYXRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGBNYXJrdXBUcmFuc2xhdGlvblZhbHVlc2AgaXMgcHJhY3RpY2FsbHkgYSBzdWIgdHlwZVxuICAgIC8vIG9mIGBSaWNoVHJhbnNsYXRpb25WYWx1ZXNgIGJ1dCBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCBoZXJlLlxuICAgIHZhbHVlcywgZm9ybWF0cyk7XG5cbiAgICAvLyBXaGVuIG9ubHkgc3RyaW5nIGNodW5rcyBhcmUgcHJvdmlkZWQgdG8gdGhlIHBhcnNlciwgb25seVxuICAgIC8vIHN0cmluZ3Mgc2hvdWxkIGJlIHJldHVybmVkIGhlcmUuIE5vdGUgdGhhdCB3ZSBuZWVkIGEgcnVudGltZVxuICAgIC8vIGNoZWNrIGZvciB0aGlzIHNpbmNlIHJpY2ggdGV4dCB2YWx1ZXMgY291bGQgYmUgYWNjaWRlbnRhbGx5XG4gICAgLy8gaW5oZXJpdGVkIGZyb20gYGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlc2AuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIiApO1xuICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgdHJhbnNsYXRlRm4ucmF3ID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhbnNsYXRlRm47XG59XG5cbi8qKlxuICogRm9yIHRoZSBzdHJpY3RseSB0eXBlZCBtZXNzYWdlcyB0byB3b3JrIHdlIGhhdmUgdG8gd3JhcCB0aGUgbmFtZXNwYWNlIGludG9cbiAqIGEgbWFuZGF0b3J5IHByZWZpeC4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICByZXR1cm4gbmFtZXNwYWNlID09PSBuYW1lc3BhY2VQcmVmaXggPyB1bmRlZmluZWQgOiBuYW1lc3BhY2Uuc2xpY2UoKG5hbWVzcGFjZVByZWZpeCArICcuJykubGVuZ3RoKTtcbn1cblxuY29uc3QgU0VDT05EID0gMTtcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xuY29uc3QgREFZID0gSE9VUiAqIDI0O1xuY29uc3QgV0VFSyA9IERBWSAqIDc7XG5jb25zdCBNT05USCA9IERBWSAqICgzNjUgLyAxMik7IC8vIEFwcHJveGltYXRpb25cbmNvbnN0IFFVQVJURVIgPSBNT05USCAqIDM7XG5jb25zdCBZRUFSID0gREFZICogMzY1O1xuY29uc3QgVU5JVF9TRUNPTkRTID0ge1xuICBzZWNvbmQ6IFNFQ09ORCxcbiAgc2Vjb25kczogU0VDT05ELFxuICBtaW51dGU6IE1JTlVURSxcbiAgbWludXRlczogTUlOVVRFLFxuICBob3VyOiBIT1VSLFxuICBob3VyczogSE9VUixcbiAgZGF5OiBEQVksXG4gIGRheXM6IERBWSxcbiAgd2VlazogV0VFSyxcbiAgd2Vla3M6IFdFRUssXG4gIG1vbnRoOiBNT05USCxcbiAgbW9udGhzOiBNT05USCxcbiAgcXVhcnRlcjogUVVBUlRFUixcbiAgcXVhcnRlcnM6IFFVQVJURVIsXG4gIHllYXI6IFlFQVIsXG4gIHllYXJzOiBZRUFSXG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykge1xuICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKHNlY29uZHMpO1xuICBpZiAoYWJzVmFsdWUgPCBNSU5VVEUpIHtcbiAgICByZXR1cm4gJ3NlY29uZCc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBIT1VSKSB7XG4gICAgcmV0dXJuICdtaW51dGUnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgREFZKSB7XG4gICAgcmV0dXJuICdob3VyJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFdFRUspIHtcbiAgICByZXR1cm4gJ2RheSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBNT05USCkge1xuICAgIHJldHVybiAnd2Vlayc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBZRUFSKSB7XG4gICAgcmV0dXJuICdtb250aCc7XG4gIH1cbiAgcmV0dXJuICd5ZWFyJztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpIHtcbiAgLy8gV2UgaGF2ZSB0byByb3VuZCB0aGUgcmVzdWx0aW5nIHZhbHVlcywgYXMgYEludGwuUmVsYXRpdmVUaW1lRm9ybWF0YFxuICAvLyB3aWxsIGluY2x1ZGUgZnJhY3Rpb25zIGxpa2UgJzIuMSBob3VycyBhZ28nLlxuICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzIC8gVU5JVF9TRUNPTkRTW3VuaXRdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgX2NhY2hlOiBjYWNoZSA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGluaXRpYWxpemVDb25maWcuY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLFxuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zO1xuICAgIGlmICghKChfb3B0aW9ucyA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9vcHRpb25zICE9PSB2b2lkIDAgJiYgX29wdGlvbnMudGltZVpvbmUpKSB7XG4gICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBcIlRoZSBgdGltZVpvbmVgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVcIiApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzID09PSBudWxsIHx8IHR5cGVGb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlRm9ybWF0c1tmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIFwiRm9ybWF0IGBcIi5jb25jYXQoZm9ybWF0TmFtZSwgXCJgIGlzIG5vdCBhdmFpbGFibGUuIFlvdSBjYW4gY29uZmlndXJlIGl0IG9uIHRoZSBwcm92aWRlciBvciBwcm92aWRlIGN1c3RvbSBvcHRpb25zLlwiKSApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHZhbHVlLFxuICAvKiogSWYgYSB0aW1lIHpvbmUgaXMgc3VwcGxpZWQsIHRoZSBgdmFsdWVgIGlzIGNvbnZlcnRlZCB0byB0aGF0IHRpbWUgem9uZS5cbiAgICogT3RoZXJ3aXNlIHRoZSB1c2VyIHRpbWUgem9uZSB3aWxsIGJlIHVzZWQuICovXG4gIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZVJhbmdlKC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHN0YXJ0LCAvKiogSWYgYSBudW1iZXIgaXMgc3VwcGxpZWQsIHRoaXMgaXMgaW50ZXJwcmV0ZWQgYXMgYSBVVEMgdGltZXN0YW1wLiAqL1xuICBlbmQsXG4gIC8qKiBJZiBhIHRpbWUgem9uZSBpcyBzdXBwbGllZCwgdGhlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIHRoYXQgdGltZSB6b25lLlxuICAgKiBPdGhlcndpc2UgdGhlIHVzZXIgdGltZSB6b25lIHdpbGwgYmUgdXNlZC4gKi9cbiAgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMubnVtYmVyLCBvcHRpb25zID0+IGZvcm1hdHRlcnMuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsTm93KCkge1xuICAgIGlmIChnbG9iYWxOb3cpIHtcbiAgICAgIHJldHVybiBnbG9iYWxOb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGUgYG5vd2AgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI25vd1wiICkpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSgvKiogVGhlIGRhdGUgdGltZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZC4gKi9cbiAgZGF0ZSwgLyoqIFRoZSByZWZlcmVuY2UgcG9pbnQgaW4gdGltZSB0byB3aGljaCBgZGF0ZWAgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gcmVsYXRpb24gdG8uICAqL1xuICBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vd0RhdGUsIHVuaXQ7XG4gICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAobm93T3JPcHRpb25zKSB7XG4gICAgICAgIGlmIChub3dPck9wdGlvbnMubm93ICE9IG51bGwpIHtcbiAgICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zLm5vdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHVuaXQgPSBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgICAgb3B0cy5zdHlsZSA9IG5vd09yT3B0aW9ucy5zdHlsZTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlcyBhcmUgc2xpZ2h0bHkgb3V0ZGF0ZWRcbiAgICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0gPSBub3dPck9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgfVxuICAgICAgaWYgKCFub3dEYXRlKSB7XG4gICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBzZWNvbmRzID0gKGRhdGVEYXRlLmdldFRpbWUoKSAtIG5vd0RhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgdW5pdCA9IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCAtMS4xIGRheXMgd2lsbCBwcm9kdWNlIFwiLTEuMSBkYXlzXCIuIFJvdW5kaW5nIGJlZm9yZSBmb3JtYXR0aW5nIGlzXG4gICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAvLyAyMDI0LTAxLTA4VDAxOjAwOjAwLjAwMFogd291bGQgcHJvZHVjZSBcInllc3RlcmRheVwiLCB3aGljaCBpcyBub3QgdGhlXG4gICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgb3B0cy5udW1lcmljID0gdW5pdCA9PT0gJ3NlY29uZCcgPyAnYXV0bycgOiAnYWx3YXlzJztcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXRSZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRzKS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0dGVycy5nZXRMaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZUJhc2VUcmFuc2xhdG9yID0gY3JlYXRlQmFzZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMucmVzb2x2ZU5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2U7XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJyZXF1aXJlIiwiUmVhY3QiLCJpbml0aWFsaXplQ29uZmlnIiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQiLCJzZXRUaW1lWm9uZUluRm9ybWF0cyIsImZvcm1hdHMiLCJ0aW1lWm9uZSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJmb3JtYXRzV2l0aFRpbWVab25lIiwiZGF0ZVRpbWUiLCJtZkRhdGVEZWZhdWx0cyIsImRhdGUiLCJkZWZhdWx0RGF0ZUZvcm1hdHMiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkZWZhdWx0VGltZUZvcm1hdHMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiY2FjaGUiLCJpbnRsRm9ybWF0dGVycyIsImdldE1lc3NhZ2VGb3JtYXQiLCJtZW1vRm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJmb3JtYXR0ZXJzIiwibWVzc2FnZSIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJmdWxsS2V5Iiwiam9pblBhdGgiLCJFcnJvciIsImNvbmNhdCIsInNwbGl0IiwiZm9yRWFjaCIsInBhcnQiLCJuZXh0IiwicHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzIiwidmFsdWVzIiwidHJhbnNmb3JtZWRWYWx1ZXMiLCJpbmRleCIsInZhbHVlIiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsImdldE1lc3NhZ2VzT3JFcnJvciIsIm9uRXJyb3IiLCJkZWZhdWx0T25FcnJvciIsInJldHJpZXZlZE1lc3NhZ2VzIiwiZXJyb3IiLCJpbnRsRXJyb3IiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIiwiTUlTU0lOR19NRVNTQUdFIiwiZ2V0UGxhaW5NZXNzYWdlIiwiY2FuZGlkYXRlIiwidW5lc2NhcGVkTWVzc2FnZSIsInJlcGxhY2UiLCJoYXNQbGFjZWhvbGRlcnMiLCJ0ZXN0IiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjb25maWciLCJtZXNzYWdlc09yRXJyb3IiLCJjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwiLCJfcmVmIiwiZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzIiwiZ2xvYmFsRm9ybWF0cyIsImdldE1lc3NhZ2VGYWxsYmFjayIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJjb2RlIiwidHJhbnNsYXRlQmFzZUZuIiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJtZXNzYWdlRm9ybWF0IiwicGxhaW5NZXNzYWdlIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJsb2NhbGVzIiwib3B0aW9ucyIsInRocm93bkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiZm9ybWF0dGVkTWVzc2FnZSIsImZvcm1hdCIsIlN0cmluZyIsIkZPUk1BVFRJTkdfRVJST1IiLCJ0cmFuc2xhdGVGbiIsInJpY2giLCJtYXJrdXAiLCJyYXciLCJoYXMiLCJfdW51c2VkIiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwiX2NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJfZm9ybWF0dGVycyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwibm93IiwiZ2xvYmFsTm93IiwiZ2xvYmFsVGltZVpvbmUiLCJhcHBseVRpbWVab25lIiwiX29wdGlvbnMiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInJlc29sdmVGb3JtYXRPck9wdGlvbnMiLCJ0eXBlRm9ybWF0cyIsImZvcm1hdE9yT3B0aW9ucyIsImZvcm1hdE5hbWUiLCJNSVNTSU5HX0ZPUk1BVCIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVyIiwiZ2V0RmFsbGJhY2siLCJkYXRlVGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJmb3JtYXRSYW5nZSIsImpvaW4iLCJudW1iZXIiLCJnZXROdW1iZXJGb3JtYXQiLCJnZXRHbG9iYWxOb3ciLCJEYXRlIiwicmVsYXRpdmVUaW1lIiwibm93T3JPcHRpb25zIiwibm93RGF0ZSIsIm9wdHMiLCJzdHlsZSIsIm51bWJlcmluZ1N5c3RlbSIsImRhdGVEYXRlIiwiZ2V0VGltZSIsIm51bWVyaWMiLCJnZXRSZWxhdGl2ZVRpbWVGb3JtYXQiLCJsaXN0Iiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInNldCIsInB1c2giLCJnZXRMaXN0Rm9ybWF0IiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJnZXQiLCJzaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/createFormatter-QqAaZwGD.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar fastMemoize = __webpack_require__(/*! @formatjs/fast-memoize */ \"(rsc)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return fastMemoize.memoize(fn, {\n        cache: createMemoCache(cache),\n        strategy: fastMemoize.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return new ConstructorFn(...args);\n    }, cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.createCache = createCache;\nexports.createIntlFormatters = createIntlFormatters;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\nexports.memoFn = memoFn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsY0FBY0MsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0MsZ0JBQWdCQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUM5QixPQUFPLENBQUNELElBQUlFLGVBQWVGLEVBQUMsS0FBTUQsSUFBSUksT0FBT0MsY0FBYyxDQUFDTCxHQUFHQyxHQUFHO1FBQ2hFSyxPQUFPSjtRQUNQSyxZQUFZLENBQUM7UUFDYkMsY0FBYyxDQUFDO1FBQ2ZDLFVBQVUsQ0FBQztJQUNiLEtBQUtULENBQUMsQ0FBQ0MsRUFBRSxHQUFHQyxHQUFHRjtBQUNqQjtBQUNBLFNBQVNVLGFBQWFSLENBQUMsRUFBRUQsQ0FBQztJQUN4QixJQUFJLFlBQVksT0FBT0MsS0FBSyxDQUFDQSxHQUFHLE9BQU9BO0lBQ3ZDLElBQUlGLElBQUlFLENBQUMsQ0FBQ1MsT0FBT0MsV0FBVyxDQUFDO0lBQzdCLElBQUksS0FBSyxNQUFNWixHQUFHO1FBQ2hCLElBQUlhLElBQUliLEVBQUVjLElBQUksQ0FBQ1osR0FBR0QsS0FBSztRQUN2QixJQUFJLFlBQVksT0FBT1ksR0FBRyxPQUFPQTtRQUNqQyxNQUFNLElBQUlFLFVBQVU7SUFDdEI7SUFDQSxPQUFPLENBQUMsYUFBYWQsSUFBSWUsU0FBU0MsTUFBSyxFQUFHZjtBQUM1QztBQUNBLFNBQVNDLGVBQWVELENBQUM7SUFDdkIsSUFBSVcsSUFBSUgsYUFBYVIsR0FBRztJQUN4QixPQUFPLFlBQVksT0FBT1csSUFBSUEsSUFBSUEsSUFBSTtBQUN4QztBQUVBLElBQUlLLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJ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QUFNMEQsMEJBQTBCSCxzQkFBc0IzRDtJQUN0RDtRQUNFLElBQUk0QyxVQUFVO1lBQ1pXLGlCQUFpQlgsVUFBVWlCO1FBQzdCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsR0FBR0QsSUFBSTtRQUNQaEI7UUFDQVksU0FBU0s7UUFDVEYsb0JBQW9CRztJQUN0QjtBQUNGO0FBRUFDLGlCQUFpQixHQUFHL0U7QUFDcEIrRSxxQkFBcUIsR0FBR2hGO0FBQ3hCZ0YsbUJBQW1CLEdBQUd4RDtBQUN0QndELDRCQUE0QixHQUFHbEM7QUFDL0JrQyxpQ0FBaUMsR0FBRy9EO0FBQ3BDK0Qsc0JBQXNCLEdBQUczRDtBQUN6QjJELHdCQUF3QixHQUFHTDtBQUMzQkssZ0JBQWdCLEdBQUd6RTtBQUNuQnlFLGNBQWMsR0FBRzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUJoZk1TSFA3LmpzP2I3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmFzdE1lbW9pemUgPSByZXF1aXJlKCdAZm9ybWF0anMvZmFzdC1tZW1vaXplJyk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuXG5sZXQgSW50bEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSW50bEVycm9yQ29kZSkge1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19NRVNTQUdFXCJdID0gXCJNSVNTSU5HX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfRk9STUFUXCJdID0gXCJNSVNTSU5HX0ZPUk1BVFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIl0gPSBcIkVOVklST05NRU5UX0ZBTExCQUNLXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfUEFUSFwiXSA9IFwiSU5TVUZGSUNJRU5UX1BBVEhcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfTUVTU0FHRVwiXSA9IFwiSU5WQUxJRF9NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX0tFWVwiXSA9IFwiSU5WQUxJRF9LRVlcIjtcbiAgSW50bEVycm9yQ29kZVtcIkZPUk1BVFRJTkdfRVJST1JcIl0gPSBcIkZPUk1BVFRJTkdfRVJST1JcIjtcbiAgcmV0dXJuIEludGxFcnJvckNvZGU7XG59KHt9KTtcbmNsYXNzIEludGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJzogJyArIG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpvaW5QYXRoKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFydHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxuICogU2VlIGFsc28gYEluaXRpYWxpemVkSW50bENvbmZpZ3VyYXRpb25gLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2socHJvcHMpIHtcbiAgcmV0dXJuIGpvaW5QYXRoKHByb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZToge30sXG4gICAgbnVtYmVyOiB7fSxcbiAgICBtZXNzYWdlOiB7fSxcbiAgICByZWxhdGl2ZVRpbWU6IHt9LFxuICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICBsaXN0OiB7fSxcbiAgICBkaXNwbGF5TmFtZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vQ2FjaGUoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9GbihmbiwgY2FjaGUpIHtcbiAgcmV0dXJuIGZhc3RNZW1vaXplLm1lbW9pemUoZm4sIHtcbiAgICBjYWNoZTogY3JlYXRlTWVtb0NhY2hlKGNhY2hlKSxcbiAgICBzdHJhdGVneTogZmFzdE1lbW9pemUuc3RyYXRlZ2llcy52YXJpYWRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lbW9Db25zdHJ1Y3RvcihDb25zdHJ1Y3RvckZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb0ZuKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGbiguLi5hcmdzKTtcbiAgfSwgY2FjaGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EYXRlVGltZUZvcm1hdCwgY2FjaGUuZGF0ZVRpbWUpO1xuICBjb25zdCBnZXROdW1iZXJGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5OdW1iZXJGb3JtYXQsIGNhY2hlLm51bWJlcik7XG4gIGNvbnN0IGdldFBsdXJhbFJ1bGVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUGx1cmFsUnVsZXMsIGNhY2hlLnBsdXJhbFJ1bGVzKTtcbiAgY29uc3QgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LCBjYWNoZS5yZWxhdGl2ZVRpbWUpO1xuICBjb25zdCBnZXRMaXN0Rm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTGlzdEZvcm1hdCwgY2FjaGUubGlzdCk7XG4gIGNvbnN0IGdldERpc3BsYXlOYW1lcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRpc3BsYXlOYW1lcywgY2FjaGUuZGlzcGxheU5hbWVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICBnZXROdW1iZXJGb3JtYXQsXG4gICAgZ2V0UGx1cmFsUnVsZXMsXG4gICAgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0LFxuICAgIGdldExpc3RGb3JtYXQsXG4gICAgZ2V0RGlzcGxheU5hbWVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10gPSBfcmVmO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IFwiIChhdCBcIi5jb25jYXQocGFyZW50UGF0aCwgXCIpXCIpO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChtZXNzYWdlT3JNZXNzYWdlcyAhPSBudWxsICYmIHR5cGVvZiBtZXNzYWdlT3JNZXNzYWdlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VPck1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBqb2luUGF0aChwYXJlbnRQYXRoLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgb25FcnJvcikge1xuICBjb25zdCBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLklOVkFMSURfS0VZLCBcIk5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFxcXCIuXFxcIiBhcyB0aGlzIGlzIHVzZWQgdG8gZXhwcmVzcyBuZXN0aW5nLiBQbGVhc2UgcmVtb3ZlIGl0IG9yIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGNoYXJhY3Rlci5cXG5cXG5JbnZhbGlkIFwiLmNvbmNhdChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA9PT0gMSA/ICdrZXknIDogJ2tleXMnLCBcIjogXCIpLmNvbmNhdChpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJyksIFwiXFxuXFxuSWYgeW91J3JlIG1pZ3JhdGluZyBmcm9tIGEgZmxhdCBzdHJ1Y3R1cmUsIHlvdSBjYW4gY29udmVydCB5b3VyIG1lc3NhZ2VzIGFzIGZvbGxvd3M6XFxuXFxuaW1wb3J0IHtzZXR9IGZyb20gXFxcImxvZGFzaFxcXCI7XFxuXFxuY29uc3QgaW5wdXQgPSB7XFxuICBcXFwib25lLm9uZVxcXCI6IFxcXCIxLjFcXFwiLFxcbiAgXFxcIm9uZS50d29cXFwiOiBcXFwiMS4yXFxcIixcXG4gIFxcXCJ0d28ub25lLm9uZVxcXCI6IFxcXCIyLjEuMVxcXCJcXG59O1xcblxcbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXFxuICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHNldChhY2MsIGtleSwgdmFsdWUpLFxcbiAge31cXG4pO1xcblxcbi8vIE91dHB1dDpcXG4vL1xcbi8vIHtcXG4vLyAgIFxcXCJvbmVcXFwiOiB7XFxuLy8gICAgIFxcXCJvbmVcXFwiOiBcXFwiMS4xXFxcIixcXG4vLyAgICAgXFxcInR3b1xcXCI6IFxcXCIxLjJcXFwiXFxuLy8gICB9LFxcbi8vICAgXFxcInR3b1xcXCI6IHtcXG4vLyAgICAgXFxcIm9uZVxcXCI6IHtcXG4vLyAgICAgICBcXFwib25lXFxcIjogXFxcIjIuMS4xXFxcIlxcbi8vICAgICB9XFxuLy8gICB9XFxuLy8gfVxcblwiKSApKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VzIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgb25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBmaW5hbE9uRXJyb3IgPSBvbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xuICBjb25zdCBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgbWVzc2FnZXMsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBJbnRsRXJyb3I7XG5leHBvcnRzLkludGxFcnJvckNvZGUgPSBJbnRsRXJyb3JDb2RlO1xuZXhwb3J0cy5jcmVhdGVDYWNoZSA9IGNyZWF0ZUNhY2hlO1xuZXhwb3J0cy5jcmVhdGVJbnRsRm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzO1xuZXhwb3J0cy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbmV4cG9ydHMuZGVmYXVsdE9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcjtcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWc7XG5leHBvcnRzLmpvaW5QYXRoID0gam9pblBhdGg7XG5leHBvcnRzLm1lbW9GbiA9IG1lbW9GbjtcbiJdLCJuYW1lcyI6WyJmYXN0TWVtb2l6ZSIsInJlcXVpcmUiLCJfZGVmaW5lUHJvcGVydHkiLCJlIiwiciIsInQiLCJfdG9Qcm9wZXJ0eUtleSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiSW50bEVycm9yQ29kZSIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsImpvaW5QYXRoIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInBhcnRzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwicHJvcHMiLCJuYW1lc3BhY2UiLCJrZXkiLCJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZUNhY2hlIiwiZGF0ZVRpbWUiLCJudW1iZXIiLCJyZWxhdGl2ZVRpbWUiLCJwbHVyYWxSdWxlcyIsImxpc3QiLCJkaXNwbGF5TmFtZXMiLCJjcmVhdGVNZW1vQ2FjaGUiLCJzdG9yZSIsImNyZWF0ZSIsImdldCIsInNldCIsIm1lbW9GbiIsImZuIiwiY2FjaGUiLCJtZW1vaXplIiwic3RyYXRlZ3kiLCJzdHJhdGVnaWVzIiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJ2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudCIsIm1lc3NhZ2VzIiwiaW52YWxpZEtleUxhYmVscyIsInBhcmVudFBhdGgiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIl9yZWYiLCJtZXNzYWdlT3JNZXNzYWdlcyIsImluY2x1ZGVzIiwia2V5TGFiZWwiLCJjb25jYXQiLCJwdXNoIiwidmFsaWRhdGVNZXNzYWdlcyIsIm9uRXJyb3IiLCJJTlZBTElEX0tFWSIsImluaXRpYWxpemVDb25maWciLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJyZXN0IiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/initializeConfig-BhfMSHP7.js\n");

/***/ })

};
;