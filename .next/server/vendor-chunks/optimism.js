"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/optimism";
exports.ids = ["vendor-chunks/optimism"];
exports.modules = {

/***/ "(ssr)/./node_modules/optimism/lib/context.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/context.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot),\n/* harmony export */   asyncFromGen: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.asyncFromGen),\n/* harmony export */   bindContext: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.bind),\n/* harmony export */   noContext: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.noContext),\n/* harmony export */   nonReactive: () => (/* binding */ nonReactive),\n/* harmony export */   parentEntrySlot: () => (/* binding */ parentEntrySlot),\n/* harmony export */   setTimeout: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.setTimeout)\n/* harmony export */ });\n/* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/context */ \"(ssr)/./node_modules/@wry/context/lib/index.js\");\n\nconst parentEntrySlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot();\nfunction nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\n\n //# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBb0M7QUFDN0IsTUFBTUMsa0JBQWtCLElBQUlELDhDQUFJQSxHQUFHO0FBQ25DLFNBQVNFLFlBQVlDLEVBQUU7SUFDMUIsT0FBT0YsZ0JBQWdCRyxTQUFTLENBQUMsS0FBSyxHQUFHRDtBQUM3QztBQUNnQjtBQUN5RSxDQUN6RixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aWxpbmd1YWwtYmxvZy8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvY29udGV4dC5qcz82OWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHdyeS9jb250ZXh0XCI7XG5leHBvcnQgY29uc3QgcGFyZW50RW50cnlTbG90ID0gbmV3IFNsb3QoKTtcbmV4cG9ydCBmdW5jdGlvbiBub25SZWFjdGl2ZShmbikge1xuICAgIHJldHVybiBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKHZvaWQgMCwgZm4pO1xufVxuZXhwb3J0IHsgU2xvdCB9O1xuZXhwb3J0IHsgYmluZCBhcyBiaW5kQ29udGV4dCwgbm9Db250ZXh0LCBzZXRUaW1lb3V0LCBhc3luY0Zyb21HZW4sIH0gZnJvbSBcIkB3cnkvY29udGV4dFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiU2xvdCIsInBhcmVudEVudHJ5U2xvdCIsIm5vblJlYWN0aXZlIiwiZm4iLCJ3aXRoVmFsdWUiLCJiaW5kIiwiYmluZENvbnRleHQiLCJub0NvbnRleHQiLCJzZXRUaW1lb3V0IiwiYXN5bmNGcm9tR2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/optimism/lib/dep.js":
/*!******************************************!*\
  !*** ./node_modules/optimism/lib/dep.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dep: () => (/* binding */ dep)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true\n};\nfunction dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = entryMethodName && _helpers_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(dep).forEach((entry)=>entry[m]());\n            depsByKey.delete(key);\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n        }\n    };\n    return depend;\n} //# sourceMappingURL=dep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2RlcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDZ0M7QUFDL0UsTUFBTUksZUFBZTtJQUNqQkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLFFBQVE7QUFDWjtBQUNPLFNBQVNDLElBQUlDLE9BQU87SUFDdkIsTUFBTUMsWUFBWSxJQUFJQztJQUN0QixNQUFNQyxZQUFZSCxXQUFXQSxRQUFRRyxTQUFTO0lBQzlDLFNBQVNDLE9BQU9DLEdBQUc7UUFDZixNQUFNQyxTQUFTZix3REFBZUEsQ0FBQ2dCLFFBQVE7UUFDdkMsSUFBSUQsUUFBUTtZQUNSLElBQUlQLE1BQU1FLFVBQVVPLEdBQUcsQ0FBQ0g7WUFDeEIsSUFBSSxDQUFDTixLQUFLO2dCQUNORSxVQUFVUSxHQUFHLENBQUNKLEtBQUtOLE1BQU0sSUFBSVc7WUFDakM7WUFDQUosT0FBT0ssUUFBUSxDQUFDWjtZQUNoQixJQUFJLE9BQU9JLGNBQWMsWUFBWTtnQkFDakNWLDZEQUFnQkEsQ0FBQ007Z0JBQ2pCQSxJQUFJYSxXQUFXLEdBQUdULFVBQVVFO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBRCxPQUFPUyxLQUFLLEdBQUcsU0FBU0EsTUFBTVIsR0FBRyxFQUFFUyxlQUFlO1FBQzlDLE1BQU1mLE1BQU1FLFVBQVVPLEdBQUcsQ0FBQ0g7UUFDMUIsSUFBSU4sS0FBSztZQUNMLE1BQU1nQixJQUFJLG1CQUNOdkIsdURBQWNBLENBQUN3QixJQUFJLENBQUNyQixjQUFjbUIsbUJBQW9CQSxrQkFBa0I7WUFDNUUsbUVBQW1FO1lBQ25FLHdFQUF3RTtZQUN4RSx3RUFBd0U7WUFDeEVwQix5REFBWUEsQ0FBQ0ssS0FBS2tCLE9BQU8sQ0FBQ0MsQ0FBQUEsUUFBU0EsS0FBSyxDQUFDSCxFQUFFO1lBQzNDZCxVQUFVa0IsTUFBTSxDQUFDZDtZQUNqQlosNkRBQWdCQSxDQUFDTTtRQUNyQjtJQUNKO0lBQ0EsT0FBT0s7QUFDWCxFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1ibG9nLy4vbm9kZV9tb2R1bGVzL29wdGltaXNtL2xpYi9kZXAuanM/M2NlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJlbnRFbnRyeVNsb3QgfSBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBoYXNPd25Qcm9wZXJ0eSwgbWF5YmVVbnN1YnNjcmliZSwgYXJyYXlGcm9tU2V0LCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmNvbnN0IEVudHJ5TWV0aG9kcyA9IHtcbiAgICBzZXREaXJ0eTogdHJ1ZSxcbiAgICBkaXNwb3NlOiB0cnVlLFxuICAgIGZvcmdldDogdHJ1ZSwgLy8gRnVsbHkgcmVtb3ZlIHBhcmVudCBFbnRyeSBmcm9tIExSVSBjYWNoZSBhbmQgY29tcHV0YXRpb24gZ3JhcGhcbn07XG5leHBvcnQgZnVuY3Rpb24gZGVwKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXBzQnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gb3B0aW9ucyAmJiBvcHRpb25zLnN1YnNjcmliZTtcbiAgICBmdW5jdGlvbiBkZXBlbmQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudEVudHJ5U2xvdC5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgZGVwID0gZGVwc0J5S2V5LmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFkZXApIHtcbiAgICAgICAgICAgICAgICBkZXBzQnlLZXkuc2V0KGtleSwgZGVwID0gbmV3IFNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZGVwZW5kT24oZGVwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGRlcCk7XG4gICAgICAgICAgICAgICAgZGVwLnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVwZW5kLmRpcnR5ID0gZnVuY3Rpb24gZGlydHkoa2V5LCBlbnRyeU1ldGhvZE5hbWUpIHtcbiAgICAgICAgY29uc3QgZGVwID0gZGVwc0J5S2V5LmdldChrZXkpO1xuICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gKGVudHJ5TWV0aG9kTmFtZSAmJlxuICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoRW50cnlNZXRob2RzLCBlbnRyeU1ldGhvZE5hbWUpKSA/IGVudHJ5TWV0aG9kTmFtZSA6IFwic2V0RGlydHlcIjtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gdXNlIGFycmF5RnJvbVNldChkZXApLmZvckVhY2ggaW5zdGVhZCBvZiBkZXAuZm9yRWFjaCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbW9kaWZ5aW5nIGEgU2V0IHdoaWxlIGl0ZXJhdGluZyBvdmVyIGl0IGNhbiBjYXVzZSBlbGVtZW50cyBpblxuICAgICAgICAgICAgLy8gdGhlIFNldCB0byBiZSByZW1vdmVkIGZyb20gdGhlIFNldCBiZWZvcmUgdGhleSd2ZSBiZWVuIGl0ZXJhdGVkIG92ZXIuXG4gICAgICAgICAgICBhcnJheUZyb21TZXQoZGVwKS5mb3JFYWNoKGVudHJ5ID0+IGVudHJ5W21dKCkpO1xuICAgICAgICAgICAgZGVwc0J5S2V5LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgbWF5YmVVbnN1YnNjcmliZShkZXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVwZW5kO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwLmpzLm1hcCJdLCJuYW1lcyI6WyJwYXJlbnRFbnRyeVNsb3QiLCJoYXNPd25Qcm9wZXJ0eSIsIm1heWJlVW5zdWJzY3JpYmUiLCJhcnJheUZyb21TZXQiLCJFbnRyeU1ldGhvZHMiLCJzZXREaXJ0eSIsImRpc3Bvc2UiLCJmb3JnZXQiLCJkZXAiLCJvcHRpb25zIiwiZGVwc0J5S2V5IiwiTWFwIiwic3Vic2NyaWJlIiwiZGVwZW5kIiwia2V5IiwicGFyZW50IiwiZ2V0VmFsdWUiLCJnZXQiLCJzZXQiLCJTZXQiLCJkZXBlbmRPbiIsInVuc3Vic2NyaWJlIiwiZGlydHkiLCJlbnRyeU1ldGhvZE5hbWUiLCJtIiwiY2FsbCIsImZvckVhY2giLCJlbnRyeSIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/dep.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/optimism/lib/entry.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/entry.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Entry: () => (/* binding */ Entry)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return(// Unknown values are not equal to each other.\n    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length && // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch(value.length){\n        case 0:\n            throw new Error(\"unknown value\");\n        case 1:\n            return value[0];\n        case 2:\n            throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nclass Entry {\n    constructor(fn){\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty) return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child)=>{\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(this.deps).forEach((dep)=>dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        } else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.withValue(entry, recomputeNewValue, [\n        entry,\n        args\n    ]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            } catch (_a) {\n            // If normalizeResult throws, just use the newer value, rather than\n            // saving the exception as entry.value[1].\n            }\n        }\n    } catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(child.parents);\n        for(let i = 0; i < parentCount; ++i){\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    } else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    } else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child)=>{\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        } catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n} //# sourceMappingURL=entry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2VudHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNlO0FBQzlELE1BQU1HLGVBQWUsRUFBRTtBQUN2QixNQUFNQyxtQkFBbUI7QUFDekIsdUVBQXVFO0FBQ3ZFLCtCQUErQjtBQUMvQixTQUFTQyxPQUFPQyxTQUFTLEVBQUVDLGVBQWU7SUFDdEMsSUFBSSxDQUFDRCxXQUFXO1FBQ1osTUFBTSxJQUFJRSxNQUFNRCxtQkFBbUI7SUFDdkM7QUFDSjtBQUNBLFNBQVNFLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUNqQixNQUFNQyxNQUFNRixFQUFFRyxNQUFNO0lBQ3BCLE9BQ0EsOENBQThDO0lBQzlDRCxNQUFNLEtBQ0Ysa0VBQWtFO0lBQ2xFQSxRQUFRRCxFQUFFRSxNQUFNLElBQ2hCLHNEQUFzRDtJQUN0REgsQ0FBQyxDQUFDRSxNQUFNLEVBQUUsS0FBS0QsQ0FBQyxDQUFDQyxNQUFNLEVBQUU7QUFDakM7QUFDQSxTQUFTRSxTQUFTQyxLQUFLO0lBQ25CLE9BQVFBLE1BQU1GLE1BQU07UUFDaEIsS0FBSztZQUFHLE1BQU0sSUFBSUwsTUFBTTtRQUN4QixLQUFLO1lBQUcsT0FBT08sS0FBSyxDQUFDLEVBQUU7UUFDdkIsS0FBSztZQUFHLE1BQU1BLEtBQUssQ0FBQyxFQUFFO0lBQzFCO0FBQ0o7QUFDQSxTQUFTQyxVQUFVRCxLQUFLO0lBQ3BCLE9BQU9BLE1BQU1FLEtBQUssQ0FBQztBQUN2QjtBQUNPLE1BQU1DO0lBQ1RDLFlBQVlDLEVBQUUsQ0FBRTtRQUNaLElBQUksQ0FBQ0EsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUlDO1FBQ3ZCLHFFQUFxRTtRQUNyRSxvRUFBb0U7UUFDcEUscUVBQXFFO1FBQ3JFLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2Is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QUFJLENBQUN5QjtZQUN0QjtZQUNBckMsT0FBT2hCLGFBQWEsR0FBRztRQUMzQjtJQUNKO0FBQ0o7QUFDQSxtRUFBbUU7QUFDbkUsb0JBQW9CO0FBQ3BCLFNBQVNjLGVBQWVFLE1BQU07SUFDMUIsSUFBSUEsT0FBT2xCLFdBQVcsQ0FBQzhDLElBQUksR0FBRyxHQUFHO1FBQzdCNUIsT0FBT2xCLFdBQVcsQ0FBQzJCLE9BQU8sQ0FBQyxDQUFDNkIsUUFBUXJDO1lBQ2hDQyxZQUFZRixRQUFRQztRQUN4QjtJQUNKO0lBQ0Esc0VBQXNFO0lBQ3RFLG1CQUFtQjtJQUNuQkQsT0FBT1EsVUFBVTtJQUNqQixxRUFBcUU7SUFDckUsOENBQThDO0lBQzlDNUMsT0FBT29DLE9BQU9oQixhQUFhLEtBQUs7QUFDcEM7QUFDQSxTQUFTa0IsWUFBWUYsTUFBTSxFQUFFQyxLQUFLO0lBQzlCQSxNQUFNckIsT0FBTyxDQUFDOEIsTUFBTSxDQUFDVjtJQUNyQkEsT0FBT2xCLFdBQVcsQ0FBQzRCLE1BQU0sQ0FBQ1Q7SUFDMUJtQyxpQkFBaUJwQyxRQUFRQztBQUM3QjtBQUNBLFNBQVNvQixlQUFlSCxLQUFLLEVBQUV6QixJQUFJO0lBQy9CLElBQUksT0FBT3lCLE1BQU1xQixTQUFTLEtBQUssWUFBWTtRQUN2QyxJQUFJO1lBQ0EvRSw2REFBZ0JBLENBQUMwRCxRQUFRLGdDQUFnQztZQUN6REEsTUFBTXNCLFdBQVcsR0FBR3RCLE1BQU1xQixTQUFTLENBQUNkLEtBQUssQ0FBQyxNQUFNaEM7UUFDcEQsRUFDQSxPQUFPa0MsR0FBRztZQUNOLG1FQUFtRTtZQUNuRSxrRUFBa0U7WUFDbEUsa0VBQWtFO1lBQ2xFLG9EQUFvRDtZQUNwRFQsTUFBTXZCLFFBQVE7WUFDZCxPQUFPO1FBQ1g7SUFDSjtJQUNBLG9FQUFvRTtJQUNwRSxpQ0FBaUM7SUFDakMsT0FBTztBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2VudHJ5LmpzPzliODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyZW50RW50cnlTbG90IH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgbWF5YmVVbnN1YnNjcmliZSwgYXJyYXlGcm9tU2V0IH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuY29uc3QgZW1wdHlTZXRQb29sID0gW107XG5jb25zdCBQT09MX1RBUkdFVF9TSVpFID0gMTAwO1xuLy8gU2luY2UgdGhpcyBwYWNrYWdlIG1pZ2h0IGJlIHVzZWQgYnJvd3NlcnMsIHdlIHNob3VsZCBhdm9pZCB1c2luZyB0aGVcbi8vIE5vZGUgYnVpbHQtaW4gYXNzZXJ0IG1vZHVsZS5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG9wdGlvbmFsTWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25hbE1lc3NhZ2UgfHwgXCJhc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUlzKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcbiAgICByZXR1cm4gKFxuICAgIC8vIFVua25vd24gdmFsdWVzIGFyZSBub3QgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICBsZW4gPiAwICYmXG4gICAgICAgIC8vIEJvdGggdmFsdWVzIG11c3QgYmUgb3JkaW5hcnkgKG9yIGJvdGggZXhjZXB0aW9uYWwpIHRvIGJlIGVxdWFsLlxuICAgICAgICBsZW4gPT09IGIubGVuZ3RoICYmXG4gICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9yIGV4Y2VwdGlvbiBtdXN0IGJlIHRoZSBzYW1lLlxuICAgICAgICBhW2xlbiAtIDFdID09PSBiW2xlbiAtIDFdKTtcbn1cbmZ1bmN0aW9uIHZhbHVlR2V0KHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlXCIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgY2FzZSAyOiB0aHJvdyB2YWx1ZVsxXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUNvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG59XG5leHBvcnQgY2xhc3MgRW50cnkge1xuICAgIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5wYXJlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGVuIHRoaXMgRW50cnkgaGFzIGNoaWxkcmVuIHRoYXQgYXJlIGRpcnR5LCB0aGlzIHByb3BlcnR5IGJlY29tZXNcbiAgICAgICAgLy8gYSBTZXQgY29udGFpbmluZyBvdGhlciBFbnRyeSBvYmplY3RzLCBib3Jyb3dlZCBmcm9tIGVtcHR5U2V0UG9vbC5cbiAgICAgICAgLy8gV2hlbiB0aGUgc2V0IGJlY29tZXMgZW1wdHksIGl0IGdldHMgcmVjeWNsZWQgYmFjayB0byBlbXB0eVNldFBvb2wuXG4gICAgICAgIHRoaXMuZGlydHlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29tcHV0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBzID0gbnVsbDtcbiAgICAgICAgKytFbnRyeS5jb3VudDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxICYmICFtaWdodEJlRGlydHkodGhpcykpIHtcbiAgICAgICAgICAgIHJlbWVtYmVyUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgbWV0aG9kIG9mIHRoZSBFbnRyeSBBUEksIGJlY2F1c2UgaXRcbiAgICAvLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhY2hlZCB0aGlzLnZhbHVlIGNhbiBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSxcbiAgICAvLyBvciBtdXN0IGJlIHJlY29tcHV0ZWQuIFRoZSBvdmVyYWxsIHBlcmZvcm1hbmNlIG9mIHRoZSBjYWNoaW5nIHN5c3RlbVxuICAgIC8vIGRlcGVuZHMgb24gdGhlIHRydXRoIG9mIHRoZSBmb2xsb3dpbmcgb2JzZXJ2YXRpb25zOiAoMSkgdGhpcy5kaXJ0eSBpc1xuICAgIC8vIHVzdWFsbHkgZmFsc2UsICgyKSB0aGlzLmRpcnR5Q2hpbGRyZW4gaXMgdXN1YWxseSBudWxsL2VtcHR5LCBhbmQgdGh1c1xuICAgIC8vICgzKSB2YWx1ZUdldCh0aGlzLnZhbHVlKSBpcyB1c3VhbGx5IHJldHVybmVkIHdpdGhvdXQgcmVjb21wdXRhdGlvbi5cbiAgICByZWNvbXB1dGUoYXJncykge1xuICAgICAgICBhc3NlcnQoIXRoaXMucmVjb21wdXRpbmcsIFwiYWxyZWFkeSByZWNvbXB1dGluZ1wiKTtcbiAgICAgICAgcmVtZW1iZXJQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBtaWdodEJlRGlydHkodGhpcylcbiAgICAgICAgICAgID8gcmVhbGx5UmVjb21wdXRlKHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICA6IHZhbHVlR2V0KHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXREaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICByZXBvcnREaXJ0eSh0aGlzKTtcbiAgICAgICAgLy8gV2UgY2FuIGdvIGFoZWFkIGFuZCB1bnN1YnNjcmliZSBoZXJlLCBzaW5jZSBhbnkgZnVydGhlciBkaXJ0eVxuICAgICAgICAvLyBub3RpZmljYXRpb25zIHdlIHJlY2VpdmUgd2lsbCBiZSByZWR1bmRhbnQsIGFuZCB1bnN1YnNjcmliaW5nIG1heVxuICAgICAgICAvLyBmcmVlIHVwIHNvbWUgcmVzb3VyY2VzLCBlLmcuIGZpbGUgd2F0Y2hlcnMuXG4gICAgICAgIG1heWJlVW5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoKTtcbiAgICAgICAgLy8gU2V2ZXIgYW55IGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcyB3aXRoIG91ciBvd24gY2hpbGRyZW4sIHNvIHRob3NlXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvbid0IHJldGFpbiB0aGlzIHBhcmVudCBFbnRyeSBpbiB0aGVpciBjaGlsZC5wYXJlbnRzIHNldHMsXG4gICAgICAgIC8vIHRoZXJlYnkgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIGZ1bGx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICBmb3JnZXRDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGVudHJ5IGhhcyBiZWVuIGtpY2tlZCBvdXQgb2YgdGhlIGNhY2hlIChpbiBpbmRleC5qcyksXG4gICAgICAgIC8vIHdlJ3ZlIGxvc3QgdGhlIGFiaWxpdHkgdG8gZmluZCBvdXQgaWYvd2hlbiB0aGlzIGVudHJ5IGJlY29tZXMgZGlydHksXG4gICAgICAgIC8vIHdoZXRoZXIgdGhhdCBoYXBwZW5zIHRocm91Z2ggYSBzdWJzY3JpcHRpb24sIGJlY2F1c2Ugb2YgYSBkaXJlY3QgY2FsbFxuICAgICAgICAvLyB0byBlbnRyeS5zZXREaXJ0eSgpLCBvciBiZWNhdXNlIG9uZSBvZiBpdHMgY2hpbGRyZW4gYmVjb21lcyBkaXJ0eS5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzIGxvc3Mgb2YgZnV0dXJlIGluZm9ybWF0aW9uLCB3ZSBoYXZlIHRvIGFzc3VtZSB0aGVcbiAgICAgICAgLy8gd29yc3QgKHRoYXQgdGhpcyBlbnRyeSBtaWdodCBoYXZlIGJlY29tZSBkaXJ0eSB2ZXJ5IHNvb24pLCBzbyB3ZSBtdXN0XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IG1hcmsgdGhpcyBlbnRyeSdzIHBhcmVudHMgYXMgZGlydHkuIE5vcm1hbGx5IHdlIGNvdWxkXG4gICAgICAgIC8vIGp1c3QgY2FsbCBlbnRyeS5zZXREaXJ0eSgpIHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50LnNldERpcnR5KCkgZm9yXG4gICAgICAgIC8vIGVhY2ggcGFyZW50LCBidXQgdGhhdCB3b3VsZCBsZWF2ZSB0aGlzIGVudHJ5IGluIHBhcmVudC5jaGlsZFZhbHVlc1xuICAgICAgICAvLyBhbmQgcGFyZW50LmRpcnR5Q2hpbGRyZW4sIHdoaWNoIHdvdWxkIHByZXZlbnQgdGhlIGNoaWxkIGZyb20gYmVpbmdcbiAgICAgICAgLy8gdHJ1bHkgZm9yZ290dGVuLlxuICAgICAgICBlYWNoUGFyZW50KHRoaXMsIChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICAgICAgICAgIGZvcmdldENoaWxkKHBhcmVudCwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3JnZXQoKSB7XG4gICAgICAgIC8vIFRoZSBjb2RlIHRoYXQgY3JlYXRlcyBFbnRyeSBvYmplY3RzIGluIGluZGV4LnRzIHdpbGwgcmVwbGFjZSB0aGlzIG1ldGhvZFxuICAgICAgICAvLyB3aXRoIG9uZSB0aGF0IGFjdHVhbGx5IHJlbW92ZXMgdGhlIEVudHJ5IGZyb20gdGhlIGNhY2hlLCB3aGljaCB3aWxsIGFsc29cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZW50cnkuZGlzcG9zZSBtZXRob2QuXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBkZXBlbmRPbihkZXApIHtcbiAgICAgICAgZGVwLmFkZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXBzLmFkZChkZXApO1xuICAgIH1cbiAgICBmb3JnZXREZXBzKCkge1xuICAgICAgICBpZiAodGhpcy5kZXBzKSB7XG4gICAgICAgICAgICBhcnJheUZyb21TZXQodGhpcy5kZXBzKS5mb3JFYWNoKGRlcCA9PiBkZXAuZGVsZXRlKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcy5jbGVhcigpO1xuICAgICAgICAgICAgZW1wdHlTZXRQb29sLnB1c2godGhpcy5kZXBzKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5FbnRyeS5jb3VudCA9IDA7XG5mdW5jdGlvbiByZW1lbWJlclBhcmVudChjaGlsZCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudEVudHJ5U2xvdC5nZXRWYWx1ZSgpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWdodEJlRGlydHkoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWxseVJlY29tcHV0ZShlbnRyeSwgYXJncykge1xuICAgIGZvcmdldENoaWxkcmVuKGVudHJ5KTtcbiAgICAvLyBTZXQgZW50cnkgYXMgdGhlIHBhcmVudCBlbnRyeSB3aGlsZSBjYWxsaW5nIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5KS5cbiAgICBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKGVudHJ5LCByZWNvbXB1dGVOZXdWYWx1ZSwgW2VudHJ5LCBhcmdzXSk7XG4gICAgaWYgKG1heWJlU3Vic2NyaWJlKGVudHJ5LCBhcmdzKSkge1xuICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgcmVjb21wdXRlZCBlbnRyeS52YWx1ZSBhbmQgZGlkIG5vdCBmYWlsIHRvXG4gICAgICAgIC8vIChyZSlzdWJzY3JpYmUsIHRoZW4gdGhpcyBFbnRyeSBpcyBubyBsb25nZXIgZXhwbGljaXRseSBkaXJ0eS5cbiAgICAgICAgc2V0Q2xlYW4oZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVHZXQoZW50cnkudmFsdWUpO1xufVxuZnVuY3Rpb24gcmVjb21wdXRlTmV3VmFsdWUoZW50cnksIGFyZ3MpIHtcbiAgICBlbnRyeS5yZWNvbXB1dGluZyA9IHRydWU7XG4gICAgY29uc3QgeyBub3JtYWxpemVSZXN1bHQgfSA9IGVudHJ5O1xuICAgIGxldCBvbGRWYWx1ZUNvcHk7XG4gICAgaWYgKG5vcm1hbGl6ZVJlc3VsdCAmJiBlbnRyeS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb2xkVmFsdWVDb3B5ID0gdmFsdWVDb3B5KGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgLy8gTWFrZSBlbnRyeS52YWx1ZSBhbiBlbXB0eSBhcnJheSwgcmVwcmVzZW50aW5nIGFuIHVua25vd24gdmFsdWUuXG4gICAgZW50cnkudmFsdWUubGVuZ3RoID0gMDtcbiAgICB0cnkge1xuICAgICAgICAvLyBJZiBlbnRyeS5mbiBzdWNjZWVkcywgZW50cnkudmFsdWUgd2lsbCBiZWNvbWUgYSBub3JtYWwgVmFsdWUuXG4gICAgICAgIGVudHJ5LnZhbHVlWzBdID0gZW50cnkuZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2aWFibGUgb2xkVmFsdWVDb3B5IHRvIGNvbXBhcmUgd2l0aCB0aGUgKHN1Y2Nlc3NmdWxseVxuICAgICAgICAvLyByZWNvbXB1dGVkKSBuZXcgZW50cnkudmFsdWUsIGFuZCB0aGV5IGFyZSBub3QgYWxyZWFkeSA9PT0gaWRlbnRpY2FsLCBnaXZlXG4gICAgICAgIC8vIG5vcm1hbGl6ZVJlc3VsdCBhIGNoYW5jZSB0byBwaWNrL2Nob29zZS9yZXVzZSBwYXJ0cyBvZiBvbGRWYWx1ZUNvcHlbMF1cbiAgICAgICAgLy8gYW5kL29yIGVudHJ5LnZhbHVlWzBdIHRvIGRldGVybWluZSB0aGUgZmluYWwgY2FjaGVkIGVudHJ5LnZhbHVlLlxuICAgICAgICBpZiAobm9ybWFsaXplUmVzdWx0ICYmIG9sZFZhbHVlQ29weSAmJiAhdmFsdWVJcyhvbGRWYWx1ZUNvcHksIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbnRyeS52YWx1ZVswXSA9IG5vcm1hbGl6ZVJlc3VsdChlbnRyeS52YWx1ZVswXSwgb2xkVmFsdWVDb3B5WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vcm1hbGl6ZVJlc3VsdCB0aHJvd3MsIGp1c3QgdXNlIHRoZSBuZXdlciB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICAgICAvLyBzYXZpbmcgdGhlIGV4Y2VwdGlvbiBhcyBlbnRyeS52YWx1ZVsxXS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBlbnRyeS5mbiB0aHJvd3MsIGVudHJ5LnZhbHVlIHdpbGwgaG9sZCB0aGF0IGV4Y2VwdGlvbi5cbiAgICAgICAgZW50cnkudmFsdWVbMV0gPSBlO1xuICAgIH1cbiAgICAvLyBFaXRoZXIgd2F5LCB0aGlzIGxpbmUgaXMgYWx3YXlzIHJlYWNoZWQuXG4gICAgZW50cnkucmVjb21wdXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1pZ2h0QmVEaXJ0eShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5kaXJ0eSB8fCAhIShlbnRyeS5kaXJ0eUNoaWxkcmVuICYmIGVudHJ5LmRpcnR5Q2hpbGRyZW4uc2l6ZSk7XG59XG5mdW5jdGlvbiBzZXRDbGVhbihlbnRyeSkge1xuICAgIGVudHJ5LmRpcnR5ID0gZmFsc2U7XG4gICAgaWYgKG1pZ2h0QmVEaXJ0eShlbnRyeSkpIHtcbiAgICAgICAgLy8gVGhpcyBFbnRyeSBtYXkgc3RpbGwgaGF2ZSBkaXJ0eSBjaGlsZHJlbiwgaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndFxuICAgICAgICAvLyBsZXQgb3VyIHBhcmVudHMga25vdyB3ZSdyZSBjbGVhbiBqdXN0IHlldC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBvcnRDbGVhbihlbnRyeSk7XG59XG5mdW5jdGlvbiByZXBvcnREaXJ0eShjaGlsZCkge1xuICAgIGVhY2hQYXJlbnQoY2hpbGQsIHJlcG9ydERpcnR5Q2hpbGQpO1xufVxuZnVuY3Rpb24gcmVwb3J0Q2xlYW4oY2hpbGQpIHtcbiAgICBlYWNoUGFyZW50KGNoaWxkLCByZXBvcnRDbGVhbkNoaWxkKTtcbn1cbmZ1bmN0aW9uIGVhY2hQYXJlbnQoY2hpbGQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcGFyZW50Q291bnQgPSBjaGlsZC5wYXJlbnRzLnNpemU7XG4gICAgaWYgKHBhcmVudENvdW50KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBhcnJheUZyb21TZXQoY2hpbGQucGFyZW50cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgY2FsbGJhY2socGFyZW50c1tpXSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gTGV0IGEgcGFyZW50IEVudHJ5IGtub3cgdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuIG1heSBiZSBkaXJ0eS5cbmZ1bmN0aW9uIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJQYXJlbnQoY2hpbGQpIGJlZm9yZSBjYWxsaW5nXG4gICAgLy8gcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKS5cbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xuICAgIGFzc2VydChtaWdodEJlRGlydHkoY2hpbGQpKTtcbiAgICBjb25zdCBwYXJlbnRXYXNDbGVhbiA9ICFtaWdodEJlRGlydHkocGFyZW50KTtcbiAgICBpZiAoIXBhcmVudC5kaXJ0eUNoaWxkcmVuKSB7XG4gICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gZW1wdHlTZXRQb29sLnBvcCgpIHx8IG5ldyBTZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudC5kaXJ0eUNoaWxkcmVuLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBrbm93IHRoaXMgY2hpbGQgaXMgZGlydHksIHRoZW4gd2UgbXVzdCBoYXZlIGFscmVhZHlcbiAgICAgICAgLy8gaW5mb3JtZWQgb3VyIG93biBwYXJlbnRzIHRoYXQgd2UgYXJlIGRpcnR5LCBzbyB3ZSBjYW4gdGVybWluYXRlXG4gICAgICAgIC8vIHRoZSByZWN1cnNpb24gZWFybHkuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyZW50LmRpcnR5Q2hpbGRyZW4uYWRkKGNoaWxkKTtcbiAgICAvLyBJZiBwYXJlbnQgd2FzIGNsZWFuIGJlZm9yZSwgaXQganVzdCBiZWNhbWUgKHBvc3NpYmx5KSBkaXJ0eSAoYWNjb3JkaW5nIHRvXG4gICAgLy8gbWlnaHRCZURpcnR5KSwgc2luY2Ugd2UganVzdCBhZGRlZCBjaGlsZCB0byBwYXJlbnQuZGlydHlDaGlsZHJlbi5cbiAgICBpZiAocGFyZW50V2FzQ2xlYW4pIHtcbiAgICAgICAgcmVwb3J0RGlydHkocGFyZW50KTtcbiAgICB9XG59XG4vLyBMZXQgYSBwYXJlbnQgRW50cnkga25vdyB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4gaXMgbm8gbG9uZ2VyIGRpcnR5LlxuZnVuY3Rpb24gcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgLy8gTXVzdCBoYXZlIGNhbGxlZCByZW1lbWJlckNoaWxkKGNoaWxkKSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkuXG4gICAgYXNzZXJ0KHBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKTtcbiAgICBhc3NlcnQoIW1pZ2h0QmVEaXJ0eShjaGlsZCkpO1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBwYXJlbnQuY2hpbGRWYWx1ZXMuZ2V0KGNoaWxkKTtcbiAgICBpZiAoY2hpbGRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgdmFsdWVDb3B5KGNoaWxkLnZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF2YWx1ZUlzKGNoaWxkVmFsdWUsIGNoaWxkLnZhbHVlKSkge1xuICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICB9XG4gICAgcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICBpZiAobWlnaHRCZURpcnR5KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBvcnRDbGVhbihwYXJlbnQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgY29uc3QgZGMgPSBwYXJlbnQuZGlydHlDaGlsZHJlbjtcbiAgICBpZiAoZGMpIHtcbiAgICAgICAgZGMuZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgaWYgKGRjLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChlbXB0eVNldFBvb2wubGVuZ3RoIDwgUE9PTF9UQVJHRVRfU0laRSkge1xuICAgICAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKGRjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBlbnRyeSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVcbi8vIHJlbW92ZWQgY2hpbGRyZW4uXG5mdW5jdGlvbiBmb3JnZXRDaGlsZHJlbihwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmNoaWxkVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5mb3JFYWNoKChfdmFsdWUsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGlzIHBhcmVudCBFbnRyeSBmcm9tIGFueSBzZXRzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBieSB0aGVcbiAgICAvLyBhZGRUb1NldCBtZXRob2QuXG4gICAgcGFyZW50LmZvcmdldERlcHMoKTtcbiAgICAvLyBBZnRlciB3ZSBmb3JnZXQgYWxsIG91ciBjaGlsZHJlbiwgdGhpcy5kaXJ0eUNoaWxkcmVuIG11c3QgYmUgZW1wdHlcbiAgICAvLyBhbmQgdGhlcmVmb3JlIG11c3QgaGF2ZSBiZWVuIHJlc2V0IHRvIG51bGwuXG4gICAgYXNzZXJ0KHBhcmVudC5kaXJ0eUNoaWxkcmVuID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGZvcmdldENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnRzLmRlbGV0ZShwYXJlbnQpO1xuICAgIHBhcmVudC5jaGlsZFZhbHVlcy5kZWxldGUoY2hpbGQpO1xuICAgIHJlbW92ZURpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBtYXliZVN1YnNjcmliZShlbnRyeSwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZW50cnkuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZW50cnkpOyAvLyBQcmV2ZW50IGRvdWJsZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBlbnRyeS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgRW50cnkgaGFzIGEgc3Vic2NyaWJlIGZ1bmN0aW9uIGFuZCBpdCB0aHJldyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIChvciBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiBpdCBwcmV2aW91c2x5IHJldHVybmVkIG5vdyB0aHJvd3MpLFxuICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBzdWJzY3JpYmUgKG9yXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSksIGFuZCB0aGlzIEVudHJ5IHNob3VsZCByZW1haW4gZGlydHkuXG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybmluZyB0cnVlIGluZGljYXRlcyBlaXRoZXIgdGhhdCB0aGVyZSB3YXMgbm8gZW50cnkuc3Vic2NyaWJlXG4gICAgLy8gZnVuY3Rpb24gb3IgdGhhdCBpdCBzdWNjZWVkZWQuXG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyeS5qcy5tYXAiXSwibmFtZXMiOlsicGFyZW50RW50cnlTbG90IiwibWF5YmVVbnN1YnNjcmliZSIsImFycmF5RnJvbVNldCIsImVtcHR5U2V0UG9vbCIsIlBPT0xfVEFSR0VUX1NJWkUiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJvcHRpb25hbE1lc3NhZ2UiLCJFcnJvciIsInZhbHVlSXMiLCJhIiwiYiIsImxlbiIsImxlbmd0aCIsInZhbHVlR2V0IiwidmFsdWUiLCJ2YWx1ZUNvcHkiLCJzbGljZSIsIkVudHJ5IiwiY29uc3RydWN0b3IiLCJmbiIsInBhcmVudHMiLCJTZXQiLCJjaGlsZFZhbHVlcyIsIk1hcCIsImRpcnR5Q2hpbGRyZW4iLCJkaXJ0eSIsInJlY29tcHV0aW5nIiwiZGVwcyIsImNvdW50IiwicGVlayIsIm1pZ2h0QmVEaXJ0eSIsInJlbWVtYmVyUGFyZW50IiwicmVjb21wdXRlIiwiYXJncyIsInJlYWxseVJlY29tcHV0ZSIsInNldERpcnR5IiwicmVwb3J0RGlydHkiLCJkaXNwb3NlIiwiZm9yZ2V0Q2hpbGRyZW4iLCJlYWNoUGFyZW50IiwicGFyZW50IiwiY2hpbGQiLCJmb3JnZXRDaGlsZCIsImZvcmdldCIsImRlcGVuZE9uIiwiZGVwIiwiYWRkIiwicG9wIiwiZm9yZ2V0RGVwcyIsImZvckVhY2giLCJkZWxldGUiLCJjbGVhciIsInB1c2giLCJnZXRWYWx1ZSIsImhhcyIsInNldCIsInJlcG9ydERpcnR5Q2hpbGQiLCJyZXBvcnRDbGVhbkNoaWxkIiwiZW50cnkiLCJ3aXRoVmFsdWUiLCJyZWNvbXB1dGVOZXdWYWx1ZSIsIm1heWJlU3Vic2NyaWJlIiwic2V0Q2xlYW4iLCJub3JtYWxpemVSZXN1bHQiLCJvbGRWYWx1ZUNvcHkiLCJhcHBseSIsIl9hIiwiZSIsInNpemUiLCJyZXBvcnRDbGVhbiIsImNhbGxiYWNrIiwicGFyZW50Q291bnQiLCJpIiwicGFyZW50V2FzQ2xlYW4iLCJjaGlsZFZhbHVlIiwiZ2V0IiwicmVtb3ZlRGlydHlDaGlsZCIsImRjIiwiX3ZhbHVlIiwic3Vic2NyaWJlIiwidW5zdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/entry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/optimism/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/helpers.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayFromSet: () => (/* binding */ arrayFromSet),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   maybeUnsubscribe: () => (/* binding */ maybeUnsubscribe)\n/* harmony export */ });\nconst { hasOwnProperty } = Object.prototype;\nconst arrayFromSet = Array.from || function(set) {\n    const array = [];\n    set.forEach((item)=>array.push(item));\n    return array;\n};\nfunction maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sTUFBTSxFQUFFQSxjQUFjLEVBQUcsR0FBR0MsT0FBT0MsU0FBUyxDQUFDO0FBQzdDLE1BQU1DLGVBQWVDLE1BQU1DLElBQUksSUFDbEMsU0FBVUMsR0FBRztJQUNULE1BQU1DLFFBQVEsRUFBRTtJQUNoQkQsSUFBSUUsT0FBTyxDQUFDQyxDQUFBQSxPQUFRRixNQUFNRyxJQUFJLENBQUNEO0lBQy9CLE9BQU9GO0FBQ1gsRUFBRTtBQUNDLFNBQVNJLGlCQUFpQkMsVUFBVTtJQUN2QyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHRDtJQUN4QixJQUFJLE9BQU9DLGdCQUFnQixZQUFZO1FBQ25DRCxXQUFXQyxXQUFXLEdBQUcsS0FBSztRQUM5QkE7SUFDSjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWJsb2cvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2hlbHBlcnMuanM/MmMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5leHBvcnQgY29uc3QgYXJyYXlGcm9tU2V0ID0gQXJyYXkuZnJvbSB8fFxuICAgIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgc2V0LmZvckVhY2goaXRlbSA9PiBhcnJheS5wdXNoKGl0ZW0pKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5leHBvcnQgZnVuY3Rpb24gbWF5YmVVbnN1YnNjcmliZShlbnRyeU9yRGVwKSB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gZW50cnlPckRlcDtcbiAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50cnlPckRlcC51bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsImFycmF5RnJvbVNldCIsIkFycmF5IiwiZnJvbSIsInNldCIsImFycmF5IiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwibWF5YmVVbnN1YnNjcmliZSIsImVudHJ5T3JEZXAiLCJ1bnN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/optimism/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyTrie: () => (/* reexport safe */ _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie),\n/* harmony export */   Slot: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.Slot),\n/* harmony export */   asyncFromGen: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.asyncFromGen),\n/* harmony export */   bindContext: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.bindContext),\n/* harmony export */   defaultMakeCacheKey: () => (/* binding */ defaultMakeCacheKey),\n/* harmony export */   dep: () => (/* reexport safe */ _dep_js__WEBPACK_IMPORTED_MODULE_3__.dep),\n/* harmony export */   noContext: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.noContext),\n/* harmony export */   nonReactive: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.nonReactive),\n/* harmony export */   setTimeout: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.setTimeout),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/trie */ \"(ssr)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wry/caches */ \"(ssr)/./node_modules/@wry/caches/lib/strong.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entry.js */ \"(ssr)/./node_modules/optimism/lib/entry.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _dep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dep.js */ \"(ssr)/./node_modules/optimism/lib/dep.js\");\n\n\n\n\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\n\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nfunction defaultMakeCacheKey(...args) {\n    const trie = defaultKeyTrie || (defaultKeyTrie = new _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\n\n;\nconst caches = new Set();\nfunction wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = _wry_caches__WEBPACK_IMPORTED_MODULE_4__.StrongCache } = Object.create(null)) {\n    const cache = typeof cacheOption === \"function\" ? new cacheOption(max, (entry)=>entry.dispose()) : cacheOption;\n    const optimistic = function() {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new _entry_js__WEBPACK_IMPORTED_MODULE_1__.Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = ()=>cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!_context_js__WEBPACK_IMPORTED_MODULE_2__.parentEntrySlot.hasValue()) {\n            caches.forEach((cache)=>cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: ()=>cache.size,\n        configurable: false,\n        enumerable: false\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNTO0FBQ1A7QUFDWTtBQUMvQyxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLHlFQUF5RTtBQUN6RSxzRUFBc0U7QUFDdEUseUVBQXlFO0FBQ3pFLHNFQUFzRTtBQUM4QjtBQUNwRyw0RUFBNEU7QUFDNUUsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSwrQ0FBK0M7QUFDaEI7QUFDL0IsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSwwRUFBMEU7QUFDMUUsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLElBQUlXO0FBQ0csU0FBU0Msb0JBQW9CLEdBQUdDLElBQUk7SUFDdkMsTUFBTUMsT0FBT0gsa0JBQW1CQSxDQUFBQSxpQkFBaUIsSUFBSVgsMkNBQUlBLENBQUMsT0FBT2UsWUFBWSxXQUFVO0lBQ3ZGLE9BQU9ELEtBQUtFLFdBQVcsQ0FBQ0g7QUFDNUI7QUFDQSw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLG9EQUFvRDtBQUN6Qjs7QUFFM0IsTUFBTUssU0FBUyxJQUFJQztBQUNaLFNBQVNDLEtBQUtDLGdCQUFnQixFQUFFLEVBQUVDLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxlQUFlZCxtQkFBbUIsRUFBRWUsZUFBZSxFQUFFQyxTQUFTLEVBQUVDLE9BQU9DLGNBQWM3QixvREFBVyxFQUFHLEdBQUc4QixPQUFPQyxNQUFNLENBQUMsS0FBSztJQUM5TCxNQUFNSCxRQUFRLE9BQU9DLGdCQUFnQixhQUMvQixJQUFJQSxZQUFZUixLQUFLVyxDQUFBQSxRQUFTQSxNQUFNQyxPQUFPLE1BQzNDSjtJQUNOLE1BQU1LLGFBQWE7UUFDZixNQUFNQyxNQUFNVixhQUFhVyxLQUFLLENBQUMsTUFBTVosVUFBVUEsUUFBUVksS0FBSyxDQUFDLE1BQU1DLGFBQWFBO1FBQ2hGLElBQUlGLFFBQVEsS0FBSyxHQUFHO1lBQ2hCLE9BQU9mLGlCQUFpQmdCLEtBQUssQ0FBQyxNQUFNQztRQUN4QztRQUNBLElBQUlMLFFBQVFKLE1BQU1VLEdBQUcsQ0FBQ0g7UUFDdEIsSUFBSSxDQUFDSCxPQUFPO1lBQ1JKLE1BQU1XLEdBQUcsQ0FBQ0osS0FBS0gsUUFBUSxJQUFJL0IsNENBQUtBLENBQUNtQjtZQUNqQ1ksTUFBTU4sZUFBZSxHQUFHQTtZQUN4Qk0sTUFBTUwsU0FBUyxHQUFHQTtZQUNsQix1RUFBdUU7WUFDdkUscURBQXFEO1lBQ3JESyxNQUFNUSxNQUFNLEdBQUcsSUFBTVosTUFBTWEsTUFBTSxDQUFDTjtRQUN0QztRQUNBLE1BQU1PLFFBQVFWLE1BQU1XLFNBQVMsQ0FBQ0MsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ1Y7UUFDekQsaUVBQWlFO1FBQ2pFLDhDQUE4QztRQUM5Q1QsTUFBTVcsR0FBRyxDQUFDSixLQUFLSDtRQUNmZixPQUFPK0IsR0FBRyxDQUFDcEI7UUFDWCxvRUFBb0U7UUFDcEUsbUVBQW1FO1FBQ25FLHVEQUF1RDtRQUN2RCxJQUFJLENBQUMxQix3REFBZUEsQ0FBQytDLFFBQVEsSUFBSTtZQUM3QmhDLE9BQU9pQyxPQUFPLENBQUN0QixDQUFBQSxRQUFTQSxNQUFNdUIsS0FBSztZQUNuQ2xDLE9BQU9tQyxLQUFLO1FBQ2hCO1FBQ0EsT0FBT1Y7SUFDWDtJQUNBWixPQUFPdUIsY0FBYyxDQUFDbkIsWUFBWSxRQUFRO1FBQ3RDSSxLQUFLLElBQU1WLE1BQU0wQixJQUFJO1FBQ3JCQyxjQUFjO1FBQ2RDLFlBQVk7SUFDaEI7SUFDQTFCLE9BQU8yQixNQUFNLENBQUN2QixXQUFXd0IsT0FBTyxHQUFHO1FBQy9CckM7UUFDQUc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7SUFDSjtJQUNBLFNBQVMrQixTQUFTeEIsR0FBRztRQUNqQixNQUFNSCxRQUFRRyxPQUFPUCxNQUFNVSxHQUFHLENBQUNIO1FBQy9CLElBQUlILE9BQU87WUFDUEEsTUFBTTRCLFFBQVE7UUFDbEI7SUFDSjtJQUNBMUIsV0FBV3lCLFFBQVEsR0FBR0E7SUFDdEJ6QixXQUFXMkIsS0FBSyxHQUFHLFNBQVNBO1FBQ3hCRixTQUFTbEMsYUFBYVcsS0FBSyxDQUFDLE1BQU1DO0lBQ3RDO0lBQ0EsU0FBU3lCLFFBQVEzQixHQUFHO1FBQ2hCLE1BQU1ILFFBQVFHLE9BQU9QLE1BQU1VLEdBQUcsQ0FBQ0g7UUFDL0IsSUFBSUgsT0FBTztZQUNQLE9BQU9BLE1BQU0rQixJQUFJO1FBQ3JCO0lBQ0o7SUFDQTdCLFdBQVc0QixPQUFPLEdBQUdBO0lBQ3JCNUIsV0FBVzZCLElBQUksR0FBRyxTQUFTQTtRQUN2QixPQUFPRCxRQUFRckMsYUFBYVcsS0FBSyxDQUFDLE1BQU1DO0lBQzVDO0lBQ0EsU0FBUzJCLFVBQVU3QixHQUFHO1FBQ2xCLE9BQU9BLE1BQU1QLE1BQU1hLE1BQU0sQ0FBQ04sT0FBTztJQUNyQztJQUNBRCxXQUFXOEIsU0FBUyxHQUFHQTtJQUN2QjlCLFdBQVdNLE1BQU0sR0FBRyxTQUFTQTtRQUN6QixPQUFPd0IsVUFBVXZDLGFBQWFXLEtBQUssQ0FBQyxNQUFNQztJQUM5QztJQUNBSCxXQUFXVCxZQUFZLEdBQUdBO0lBQzFCUyxXQUFXK0IsTUFBTSxHQUFHekMsVUFBVSxTQUFTeUM7UUFDbkMsT0FBT3hDLGFBQWFXLEtBQUssQ0FBQyxNQUFNWixRQUFRWSxLQUFLLENBQUMsTUFBTUM7SUFDeEQsSUFBSVo7SUFDSixPQUFPSyxPQUFPMkIsTUFBTSxDQUFDdkI7QUFDekIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aWxpbmd1YWwtYmxvZy8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvaW5kZXguanM/MzY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmllIH0gZnJvbSBcIkB3cnkvdHJpZVwiO1xuaW1wb3J0IHsgU3Ryb25nQ2FjaGUgfSBmcm9tIFwiQHdyeS9jYWNoZXNcIjtcbmltcG9ydCB7IEVudHJ5IH0gZnJvbSBcIi4vZW50cnkuanNcIjtcbmltcG9ydCB7IHBhcmVudEVudHJ5U2xvdCB9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbi8vIFRoZXNlIGhlbHBlciBmdW5jdGlvbnMgYXJlIGltcG9ydGFudCBmb3IgbWFraW5nIG9wdGltaXNtIHdvcmsgd2l0aFxuLy8gYXN5bmNocm9ub3VzIGNvZGUuIEluIG9yZGVyIHRvIHJlZ2lzdGVyIHBhcmVudC1jaGlsZCBkZXBlbmRlbmNpZXMsXG4vLyBvcHRpbWlzbSBuZWVkcyB0byBrbm93IGFib3V0IGFueSBjdXJyZW50bHkgYWN0aXZlIHBhcmVudCBjb21wdXRhdGlvbnMuXG4vLyBJbiBvcmRpbmFyeSBzeW5jaHJvbm91cyBjb2RlLCB0aGUgcGFyZW50IGNvbnRleHQgaXMgaW1wbGljaXQgaW4gdGhlXG4vLyBleGVjdXRpb24gc3RhY2ssIGJ1dCBhc3luY2hyb25vdXMgY29kZSByZXF1aXJlcyBzb21lIGV4dHJhIGd1aWRhbmNlIGluXG4vLyBvcmRlciB0byBwcm9wYWdhdGUgY29udGV4dCBmcm9tIG9uZSBhc3luYyB0YXNrIHNlZ21lbnQgdG8gdGhlIG5leHQuXG5leHBvcnQgeyBiaW5kQ29udGV4dCwgbm9Db250ZXh0LCBub25SZWFjdGl2ZSwgc2V0VGltZW91dCwgYXN5bmNGcm9tR2VuLCBTbG90LCB9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbi8vIEEgbGlnaHRlci13ZWlnaHQgZGVwZW5kZW5jeSwgc2ltaWxhciB0byBPcHRpbWlzdGljV3JhcHBlckZ1bmN0aW9uLCBleGNlcHRcbi8vIHdpdGggb25seSBvbmUgYXJndW1lbnQsIG5vIG1ha2VDYWNoZUtleSwgbm8gd3JhcHBlZCBmdW5jdGlvbiB0byByZWNvbXB1dGUsXG4vLyBhbmQgbm8gcmVzdWx0IHZhbHVlLiBVc2VmdWwgZm9yIHJlcHJlc2VudGluZyBkZXBlbmRlbmN5IGxlYXZlcyBpbiB0aGUgZ3JhcGhcbi8vIG9mIGNvbXB1dGF0aW9uLiBTdWJzY3JpcHRpb25zIGFyZSBzdXBwb3J0ZWQuXG5leHBvcnQgeyBkZXAgfSBmcm9tIFwiLi9kZXAuanNcIjtcbi8vIFRoZSBkZWZhdWx0TWFrZUNhY2hlS2V5IGZ1bmN0aW9uIGlzIHJlbWFya2FibHkgcG93ZXJmdWwsIGJlY2F1c2UgaXQgZ2l2ZXNcbi8vIGEgdW5pcXVlIG9iamVjdCBmb3IgYW55IHNoYWxsb3ctaWRlbnRpY2FsIGxpc3Qgb2YgYXJndW1lbnRzLiBJZiB5b3UgbmVlZFxuLy8gdG8gaW1wbGVtZW50IGEgY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbiwgeW91IG1heSBmaW5kIGl0IGhlbHBmdWwgdG9cbi8vIGRlbGVnYXRlIHRoZSBmaW5hbCB3b3JrIHRvIGRlZmF1bHRNYWtlQ2FjaGVLZXksIHdoaWNoIGlzIHdoeSB3ZSBleHBvcnQgaXRcbi8vIGhlcmUuIEhvd2V2ZXIsIHlvdSBtYXkgd2FudCB0byBhdm9pZCBkZWZhdWx0TWFrZUNhY2hlS2V5IGlmIHlvdXIgcnVudGltZVxuLy8gZG9lcyBub3Qgc3VwcG9ydCBXZWFrTWFwLCBvciB5b3UgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXR1cm4gYSBzdHJpbmcga2V5LlxuLy8gSW4gdGhvc2UgY2FzZXMsIGp1c3Qgd3JpdGUgeW91ciBvd24gY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbnMuXG5sZXQgZGVmYXVsdEtleVRyaWU7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1ha2VDYWNoZUtleSguLi5hcmdzKSB7XG4gICAgY29uc3QgdHJpZSA9IGRlZmF1bHRLZXlUcmllIHx8IChkZWZhdWx0S2V5VHJpZSA9IG5ldyBUcmllKHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIpKTtcbiAgICByZXR1cm4gdHJpZS5sb29rdXBBcnJheShhcmdzKTtcbn1cbi8vIElmIHlvdSdyZSBwYXJhbm9pZCBhYm91dCBtZW1vcnkgbGVha3MsIG9yIHlvdSB3YW50IHRvIGF2b2lkIHVzaW5nIFdlYWtNYXBcbi8vIHVuZGVyIHRoZSBob29kLCBidXQgeW91IHN0aWxsIG5lZWQgdGhlIGJlaGF2aW9yIG9mIGRlZmF1bHRNYWtlQ2FjaGVLZXksXG4vLyBpbXBvcnQgdGhpcyBjb25zdHJ1Y3RvciB0byBjcmVhdGUgeW91ciBvd24gdHJpZXMuXG5leHBvcnQgeyBUcmllIGFzIEtleVRyaWUgfTtcbjtcbmNvbnN0IGNhY2hlcyA9IG5ldyBTZXQoKTtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwKG9yaWdpbmFsRnVuY3Rpb24sIHsgbWF4ID0gTWF0aC5wb3coMiwgMTYpLCBrZXlBcmdzLCBtYWtlQ2FjaGVLZXkgPSBkZWZhdWx0TWFrZUNhY2hlS2V5LCBub3JtYWxpemVSZXN1bHQsIHN1YnNjcmliZSwgY2FjaGU6IGNhY2hlT3B0aW9uID0gU3Ryb25nQ2FjaGUsIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG4gICAgY29uc3QgY2FjaGUgPSB0eXBlb2YgY2FjaGVPcHRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IG5ldyBjYWNoZU9wdGlvbihtYXgsIGVudHJ5ID0+IGVudHJ5LmRpc3Bvc2UoKSlcbiAgICAgICAgOiBjYWNoZU9wdGlvbjtcbiAgICBjb25zdCBvcHRpbWlzdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBrZXkgPSBtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwga2V5QXJncyA/IGtleUFyZ3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW50cnkgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZW50cnkgPSBuZXcgRW50cnkob3JpZ2luYWxGdW5jdGlvbikpO1xuICAgICAgICAgICAgZW50cnkubm9ybWFsaXplUmVzdWx0ID0gbm9ybWFsaXplUmVzdWx0O1xuICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgRW50cnkgdGhlIGFiaWxpdHkgdG8gdHJpZ2dlciBjYWNoZS5kZWxldGUoa2V5KSwgZXZlbiB0aG91Z2hcbiAgICAgICAgICAgIC8vIHRoZSBFbnRyeSBpdHNlbGYgZG9lcyBub3Qga25vdyBhYm91dCBrZXkgb3IgY2FjaGUuXG4gICAgICAgICAgICBlbnRyeS5mb3JnZXQgPSAoKSA9PiBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGVudHJ5LnJlY29tcHV0ZShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgLy8gTW92ZSB0aGlzIGVudHJ5IHRvIHRoZSBmcm9udCBvZiB0aGUgbGVhc3QtcmVjZW50bHkgdXNlZCBxdWV1ZSxcbiAgICAgICAgLy8gc2luY2Ugd2UganVzdCBmaW5pc2hlZCBjb21wdXRpbmcgaXRzIHZhbHVlLlxuICAgICAgICBjYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgIGNhY2hlcy5hZGQoY2FjaGUpO1xuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgZXhjZXNzIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBidXQgb25seSBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBhY3RpdmUgcGFyZW50IGVudHJ5LCBtZWFuaW5nIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGEgbGFyZ2VyXG4gICAgICAgIC8vIGNvbXB1dGF0aW9uIHRoYXQgbWlnaHQgYmUgZmx1bW1veGVkIGJ5IHRoZSBjbGVhbmluZy5cbiAgICAgICAgaWYgKCFwYXJlbnRFbnRyeVNsb3QuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY2FjaGVzLmZvckVhY2goY2FjaGUgPT4gY2FjaGUuY2xlYW4oKSk7XG4gICAgICAgICAgICBjYWNoZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW1pc3RpYywgXCJzaXplXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBjYWNoZS5zaXplLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZnJlZXplKG9wdGltaXN0aWMub3B0aW9ucyA9IHtcbiAgICAgICAgbWF4LFxuICAgICAgICBrZXlBcmdzLFxuICAgICAgICBtYWtlQ2FjaGVLZXksXG4gICAgICAgIG5vcm1hbGl6ZVJlc3VsdCxcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBjYWNoZSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBkaXJ0eUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBrZXkgJiYgY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgZW50cnkuc2V0RGlydHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHRpbWlzdGljLmRpcnR5S2V5ID0gZGlydHlLZXk7XG4gICAgb3B0aW1pc3RpYy5kaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KCkge1xuICAgICAgICBkaXJ0eUtleShtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwZWVrS2V5KGtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGtleSAmJiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucGVlaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGltaXN0aWMucGVla0tleSA9IHBlZWtLZXk7XG4gICAgb3B0aW1pc3RpYy5wZWVrID0gZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHBlZWtLZXkobWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9yZ2V0S2V5KGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8gY2FjaGUuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgb3B0aW1pc3RpYy5mb3JnZXRLZXkgPSBmb3JnZXRLZXk7XG4gICAgb3B0aW1pc3RpYy5mb3JnZXQgPSBmdW5jdGlvbiBmb3JnZXQoKSB7XG4gICAgICAgIHJldHVybiBmb3JnZXRLZXkobWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgb3B0aW1pc3RpYy5tYWtlQ2FjaGVLZXkgPSBtYWtlQ2FjaGVLZXk7XG4gICAgb3B0aW1pc3RpYy5nZXRLZXkgPSBrZXlBcmdzID8gZnVuY3Rpb24gZ2V0S2V5KCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGtleUFyZ3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfSA6IG1ha2VDYWNoZUtleTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvcHRpbWlzdGljKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJUcmllIiwiU3Ryb25nQ2FjaGUiLCJFbnRyeSIsInBhcmVudEVudHJ5U2xvdCIsImJpbmRDb250ZXh0Iiwibm9Db250ZXh0Iiwibm9uUmVhY3RpdmUiLCJzZXRUaW1lb3V0IiwiYXN5bmNGcm9tR2VuIiwiU2xvdCIsImRlcCIsImRlZmF1bHRLZXlUcmllIiwiZGVmYXVsdE1ha2VDYWNoZUtleSIsImFyZ3MiLCJ0cmllIiwiV2Vha01hcCIsImxvb2t1cEFycmF5IiwiS2V5VHJpZSIsImNhY2hlcyIsIlNldCIsIndyYXAiLCJvcmlnaW5hbEZ1bmN0aW9uIiwibWF4IiwiTWF0aCIsInBvdyIsImtleUFyZ3MiLCJtYWtlQ2FjaGVLZXkiLCJub3JtYWxpemVSZXN1bHQiLCJzdWJzY3JpYmUiLCJjYWNoZSIsImNhY2hlT3B0aW9uIiwiT2JqZWN0IiwiY3JlYXRlIiwiZW50cnkiLCJkaXNwb3NlIiwib3B0aW1pc3RpYyIsImtleSIsImFwcGx5IiwiYXJndW1lbnRzIiwiZ2V0Iiwic2V0IiwiZm9yZ2V0IiwiZGVsZXRlIiwidmFsdWUiLCJyZWNvbXB1dGUiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFkZCIsImhhc1ZhbHVlIiwiZm9yRWFjaCIsImNsZWFuIiwiY2xlYXIiLCJkZWZpbmVQcm9wZXJ0eSIsInNpemUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwib3B0aW9ucyIsImRpcnR5S2V5Iiwic2V0RGlydHkiLCJkaXJ0eSIsInBlZWtLZXkiLCJwZWVrIiwiZm9yZ2V0S2V5IiwiZ2V0S2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/index.js\n");

/***/ })

};
;